<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MAC下的守护进程]]></title>
    <url>%2F2019%2F09%2F10%2FMAC%E4%B8%8B%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程守护是定时监测软件是否在运行，如果没运行就启动这个程序，运行的话就不理会。 shell脚本文件 – BetterTouchTool.sh script123456789#!/bin/bashps_out=`ps -ef | grep -w BetterTouchTool | grep -v 'grep' | grep -v $0`result=$(echo $ps_out | grep BetterTouchTool)if [[ "$result" != "" ]];then cat /dev/null &gt; /Users/lql/Documents/Mine/sh/output/com.BetterTouchTool.plist.err cat /dev/null &gt; /Users/lql/Documents/Mine/sh/output/com.BetterTouchTool.plist.stdoutelse /Applications/BetterTouchTool.app/Contents/MacOS/BetterTouchToolfi 定时脚本 – com.BetterTouchTool.plistscript123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.BetterTouchTool.plist&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/Users/lql/Documents/Mine/sh/BetterTouchTool.sh&lt;/string&gt; &lt;/array&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/Users/lql/Documents/Mine/sh/output/com.BetterTouchTool.plist.err&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/Users/lql/Documents/Mine/sh/output/com.BetterTouchTool.plist.stdout&lt;/string&gt; &lt;key&gt;StartInterval&lt;/key&gt; &lt;integer&gt;10&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt; 说明 脚本文件放在/Users/lql/Library/LaunchAgents目录下； 每次更改脚本文件时都要先停止，重新加载，再启动，具体命令如下： script1234567launchctl stop ~/Library/LaunchAgents/com.test.plistlaunchctl unload -w ~/Library/LaunchAgents/com.test.plistlaunchctl load -w ~/Library/LaunchAgents/com.test.plistlaunchctl start ~/Library/LaunchAgents/com.test.plist# 检测配置文件是否有错误，无报错的话，会输出OKplutil -lint ~/Library/LaunchAgents/com.test.plist 可能需要在 设置 - 安全与隐私 - 辅助功能里面将shell脚本文件添加进去，如果提示无权限需要执行 chmod 777 BetterTouchTool.sh。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Hexo升级]]></title>
    <url>%2F2019%2F09%2F04%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Hexo%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[本打算在工作不忙的时候，把博客中的丢失的图片重新补充下，为此还开通了阿里云oss服务，想把图片迁移到阿里云上。在打开线上的博客后，发现特别慢，打开浏览器控制台后，发现canvas丢失了引用的js，而fontawesome的加载时间又特别长，经过一番搜索后先后修复了这两个问题，但是后来发现hexo和next的主题都不是最新版，我当前用的hexo是3.7.0，而最新版是3.9.0，next是6.7.0，而最新的是7.4.0，便先更新了hexo主题，发现冲突文件太多，一开始是一个一个文件合并，解决冲突，后来是在没耐心了就还原成之前的数据，因为之前这next主题中修改了很多文件，比如透明背景、萌萌哒等，如果要更新版本的话，这些都需要我再重新配置一遍，我的天，太多了，便放弃了更新next主题。后来就想，主题更新不了，把hexo升级下该没什么问题吧，于是便有了下面的这些操作，接口发现在打开页面的时候，会偶尔闪一下没有样式的页面，经过多方排查，后来发现是因为主题中three_waves插件导致的，就是这个波浪的动画特效，于是就先暂时将这插件禁用掉，果然没问题了，但是没有这个动画的话总感觉博客没灵魂了，得想办法还加上，不然怎么给人眼前一亮的感觉。 经过一番折腾后，怎么处理都不行，我甚至都有点想去github给作者提issue了，但是在看了项目唯一一个issue后，我突然觉得应该是我本地配置的问题，可能是升级hexo的问题，没办法又把hexo降回了原先的版本，果然没问题… 所以我讲next主题中.git文件夹删掉了，以后不再进行版本更新，根目录下的package-lock.json也加入了版本控制（之前一直都是用最新的版本，而且没事时就执行npm install，所以就没把lock文件加入版本控制），以后再迁移或更新的时候，关于hexo的执行命令就只有hexo new &quot;&quot;、hexo clean、hexo g -d了，不再执行npm相关的操作。下次有时间用laravel重新搭建一个博客，将博客迁移下。 下面是纠结的过程… next主题不可以升级，现在用的是6.7.0版本，最新版是7.4.0，使用git pull升级时会覆盖掉本地之前修改的东西（背景透明、萌萌哒、代码主题等…），主题中的next主题已经删除版本控制，重新迁移时，要在主题文件夹下执行npm install； 也不可以升级hexo的版本，如果升级的话，在升级时不能运行hexo s，否则会报错（主题中文件丢失）， 升级命令： 1234567891011121314151617181920212223242526272829303132333435363738394041用到的命令为：ncu // 检测package.json是否有更新ncu -u // 修改package.json中各依赖的版本 lql@lqls-MacBook-Air &gt; ~/Project/Blog ncuChecking /Users/lql/Project/Blog/package.json[====================] 16/16 100% babel-eslint ^10.0.1 → ^10.0.3 eslint ^5.15.3 → ^6.3.0 hexo ^3.7.0 → ^3.9.0 hexo-deployer-git ^1.0.0 → ^2.0.0 hexo-generator-feed ^1.2.2 → ^2.0.0 hexo-helper-live2d ^3.1.0 → ^3.1.1 hexo-renderer-ejs ^0.3.1 → ^1.0.0 hexo-renderer-marked ^0.3.2 → ^2.0.0 hexo-renderer-stylus ^0.3.3 → ^1.0.0 hexo-server ^0.3.1 → ^1.0.0Run ncu -u to upgrade package.json lql@lqls-MacBook-Air &gt; ~/Project/Blog ncu -uUpgrading /Users/lql/Project/Blog/package.json[====================] 16/16 100% babel-eslint ^10.0.1 → ^10.0.3 eslint ^5.15.3 → ^6.3.0 hexo ^3.7.0 → ^3.9.0 hexo-deployer-git ^1.0.0 → ^2.0.0 hexo-generator-feed ^1.2.2 → ^2.0.0 hexo-helper-live2d ^3.1.0 → ^3.1.1 hexo-renderer-ejs ^0.3.1 → ^1.0.0 hexo-renderer-marked ^0.3.2 → ^2.0.0 hexo-renderer-stylus ^0.3.3 → ^1.0.0 hexo-server ^0.3.1 → ^1.0.0Run npm install to install new versions. lql@lqls-MacBook-Air &gt; ~/Project/Blog npm install .... lql@lqls-MacBook-Air &gt; ~/Project/Blog hexo s 两个版本的对比：]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL赏析]]></title>
    <url>%2F2019%2F05%2F23%2FSQL%E8%B5%8F%E6%9E%90%2F</url>
    <content type="text"><![CDATA[整理了一些sql，比较高效… 获取订单表中各类状态的条数123456789101112SELECT sum( CASE WHEN order_status IN ( 1, 2 ) THEN 1 ELSE 0 END ) AS wait, sum( CASE WHEN order_status = 3 THEN 1 ELSE 0 END ) AS shipping, sum( CASE WHEN order_status = 4 THEN 1 ELSE 0 END ) AS receiving, sum( CASE WHEN order_status IN ( 5, 6 ) THEN 1 ELSE 0 END ) AS finish, sum( CASE WHEN order_status IN ( 7, 90, 91, 92, 93, 94 ) THEN 1 ELSE 0 END ) AS closed, count( order_status ) AS `total`FROM table_nameWHERE user_id = 47 AND delete_time = 0 ###]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决安装Xdebug后访问本地项目特别慢]]></title>
    <url>%2F2019%2F05%2F10%2F%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85Xdebug%E5%90%8E%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E7%89%B9%E5%88%AB%E6%85%A2%2F</url>
    <content type="text"><![CDATA[配置123456789101112[Xdebug]zend_extension = "E:\SoftWare\php\php-73\ext\php_xdebug-2.7.2-7.3-vc15-nts-x86_64.dll"xdebug.remote_enable = 1xdebug.remote_host = "127.0.0.1"xdebug.remote_port = 9009xdebug.remote_autostart = 1xdebug.remote_handler = "dbgp"xdebug.idekey = PHPSTORMxdebug.profiler_enable = 0xdebug.profiler_enable_trigger = 1xdebug.default_enable = "Off"xdebug.remote_mode = req 参考链接参考链接 说明 设置xdebug.remote_enable = 0或者xdebug.remote_autostart = 0，关掉这两项中的任意一项，就不会出现很慢的情况，但是关掉后就不能监听断点就行调试了; xdebug.remote_host改成127.0.0.1，而不是localhost，phpstorm中的设置也是； xdebug.remote_port只要是一个可用的端口并和phpstorm中的配置一样就行； 剩下的配置的，按照配置就行了，不要问为什么，这样做才不会这么慢。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 的一些命令]]></title>
    <url>%2F2019%2F03%2F22%2Fubuntu%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[关于用户1234567891011121314151617181920212223242526272829303132# 切换成rootsudo su #这个时候输入的是lql的密码# 输入root密码切换root用户su - 或 su root #这个时候输入的是root的密码# 重置root密码sudo passwd# 更改lql的权限为root# 新增用户adduser lql# 新增用户组groupadd webGroup# 将用户添加到用户组中usermod -g root lql# 更改文件的所有者 chown 账号名称 文件或目录（-R递归）chown -R lql web# 更改文件的用户组 chgrp 组名 文件或目录chgrp webGroup web# 给目录配置权限chmod -R 2775 web# 2 - 打开 setGID 位，意味着新创建的子文件继承与目录相同的组，新创建的子目录继承父目录的 setGID 位。# 7 - 为所有者提供 rwx 权限。# 7 - 给组 rwx 权限。# 5 - 为其他人提供 rx 权限。 修改默认启动级别假设现在在图形用户界面，打开终端，输入如下命令： 1sudo systemctl set-default multi-user.target 现在如果想进入图形用户界面（仅进入一次，重启系统后仍然会进入命令行模式），可执行如下命令： 1sudo systemctl start lightdm 如果想设置为系统启动后默认进入图形用户界面，执行如下命令： 1systemctl set-default graphical.target 然后执行reboot命令重启系统即可。 更换镜像源 备份默认源地址 sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 删除sources.list文件，并新建此文件，粘贴下面这些内容： 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新源 apt-get update 软件操作的相关命令 12345678910111213141516sudo apt-get update 更新源 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package --reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package --purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 xshell/xftp登陆Win10 Linux子系统 备份文件 12cd /etc/sshsudo cp sshd_config sshd_config.bak 修改sshd_config 12345sudo vim sshd_configPort 2233 #修改端口ListenAddress 0.0.0.0 #打开本地监听#StrictModes yes #注释掉PasswordAuthentication yes #允许密码登陆 重启ssh sudo service ssh restart xshell/xftp登录 12345678910# xshell连接ip：127.0.0.1协议：ssh端口：2233-------# xftp连接ip：127.0.0.1协议：sftp端口：22方式：password 安装nginx+php+mysql安装nginx 安装 apt-get -y install nginx nginx默认根目录 /usr/share/nginx/html 修改端口 1234567891011# 找到nginx.confwhereis nginx.conf# cd 到 /etc/nginx 目录下，在nginx.conf文件中没看到listen 80的字样，# 切换到/etc/nginx/sites-enabled/找到default文件server &#123; listen 80 default_server; listen [::]:80 default_server;# 修改80为888# 重启nginxservice nginx stopservice nginx start 配置文件 123456789101112131415161718server &#123; listen 8881; listen [::]:8881; root /usr/share/nginx/web/yifu/public; index index.html index.htm index.nginx-debian.html index.php; server_name _; location / &#123; try_files $uri $uri/ =404; &#125; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; &#125;&#125;]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xshell/xftp登陆Win10 Linux子系统]]></title>
    <url>%2F2019%2F01%2F23%2Fxshell-xftp%E7%99%BB%E9%99%86Win10%20Linux%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[备份文件 12cd /etc/sshsudo cp sshd_config sshd_config.bak 修改sshd_config 12345sudo vim sshd_configPort 2233 #修改端口ListenAddress 0.0.0.0 #打开本地监听#StrictModes yes #注释掉PasswordAuthentication yes #允许密码登陆 重启ssh sudo service ssh restart xshell登录 123ip：127.0.0.1协议：ssh端口：2233 xftp登录 1234ip：127.0.0.1协议：sftp端口：22方式：password]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP基础知识易错点]]></title>
    <url>%2F2019%2F01%2F22%2FPHP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%98%93%E9%94%99%E7%82%B9%2F</url>
    <content type="text"><![CDATA[关于弱类型题目123456789&lt;?php $str1 = 'yabadabadoo'; $str2 = 'yaba'; if(strpos($str1, $str2))&#123; echo $str1 . 'contains ' . $str2; &#125;else&#123; echo $str1 . 'does not contain ' . $str2; &#125; 解析正确运行的输出结果: &quot;yabadabadoo&quot; does not contain &quot;yaba&quot; strpos 是返回字符串 str2 在 str1 的位置，没有找到则返回 false ，然而实际上这次返回了 0 而在if语句中0也被当作false,所以我们需要对false做类型判断，正确的代码如下: 12345678&lt;?php $str1 = 'yabadabadoo'; $str2 = 'yaba'; if(strpos($str1, $str2) !== false)&#123; echo $str1 . 'contains' . $str2; &#125;else&#123; echo $str1 . 'does not contain' . $str2; &#125; 需要注意的是我们使用了 !== ，在php 和 JS中 !=相对== 更为严格需要要求数据类型一致. 下面的输出结果会是怎样？题目1234567891011&lt;?php $x = 5; echo $x; echo '&lt;br /&gt;'; echo $x++ + $x++; echo '&lt;br /&gt;'; echo $x; echo '&lt;br /&gt;'; echo $x-- - $x--; echo '&lt;br /&gt;'; echo $x; 解析关于 $x++ 和 $x– 这个问题其实非常容易遇见，我们只需记住 $x++ 使用最近的值，然后才自增。运算符的优先级， ++ 是明显高于 + ，因此先执行++ 再执行 + 。关于运算符的优先级，有的时候我们真的可以通过括号来让我们的程序更让人直观的了解，毕竟代码不光是用于执行的，有的时候或许团队的可读性也是提高效率的一种。 关于变量的引用题目1234&lt;?php $a = '1'; $b = &amp;$a; $b = "2$b"; 请问 $a 和 ​$b 的值各位多少？ 解析部分第一时间会想到 $a=’1’ $b=’21’ ,仔细一看 $b=&amp;$a ,这里 $b 是变量 $a 的引用，而不是直接赋值。 这里输出 a=21;b=21 下面是true还是false题目1234&lt;?php var_dump(0123 == 123); var_dump('0123' == 123); var_dump('0123' === 123); 解析var_dump(0123 == 123);// false,PHP会默认把0123当作8进制来处理，实际转化为10进制就是83，显然这不是相等的。var_dump(&#39;0123&#39; == 123);// true 这里php会非常有趣的将’0123’转换成一个数字而且默认去掉了前面的0也就是 123==123var_dump(&#39;0123&#39; === 123);// false 很显然上面的问题已经说过了数字和字符串类型不一致。 下面的代码有什么问题吗？输出会是什么，怎样修复它题目1234567891011121314&lt;?php $referenceTable = array(); $referenceTable['val1'] = array(1, 2); $referenceTable['val2'] = 3; $referenceTable['val3'] = array(4, 5); $testArray = array(); $testArray = array_merge($testArray, $referenceTable['val1']); var_dump($testArray); $testArray = array_merge($testArray, $referenceTable['val2']); var_dump($testArray); $testArray = array_merge($testArray, $referenceTable['val3']); var_dump($testArray); 解析 实际输出如下： array(2) { [0]=&gt; int(1) [1]=&gt; int(2) }NULLNULL 运行的时候你或许还能看到下面的警告 Warning: array_merge(): Argument #2 is not an arrayWarning: array_merge(): Argument #1 is not an array array_merge 需要传入的参数都是数组，如果不是，则会返回null。 你可以这样修改 1234567&lt;?php $testArray = array_merge($testArray, (array)$referenceTable['val1']); var_dump($testArray); $testArray = array_merge($testArray, (array)$referenceTable['val2']); var_dump($testArray); $testArray = array_merge($testArray, (array)$referenceTable['val3']); var_dump($testArray); $x应该是输出什么？题目123&lt;?php $x = true and false; var_dump($x); 解析 这里依旧是强调运算符的优先级，＝ 会比 and级别高点，因此等同下面的代码 $x = true; true and false 答案显而易见。 经过下面的运算 $x的值应该是多少？题目12&lt;?php $x = 3 + "15%" + "$25" 解析答案是 18 ，PHP是会根据上下文实现 类型的自动转换上面的代码我们可以这样理解： 如果我们在与字符串进行数学运算，实际php会尽可能将字符串中的数组进行转换，如果是数字开头的话则转换成改数字比如”15%”会变成15,如果不是数字开头则会变成0; 上面的运算类似下面 ：$x = 3 + 15 + 0 $x应该是输出什么？题目123&lt;?php $x = true and false; var_dump($x); 解析 这里依旧是强调运算符的优先级，＝ 会比 and级别高点，因此等同下面的代码 $x = true; true and false 答案显而易见。 运行下面的代码， $text 的值是多少？ strlen($text) 又会返回什么结果？题目123&lt;?php $text = 'John '; $text[10] = 'Doe'; 解析上面代码执行完毕后 $text = &quot;John D&quot; (John后面会有连续的5个空格) strlen($text) 会返回11 下面的输出结果会是什么题目123456789&lt;?php $v = 1; $m = 2; $l = 3; if($l &gt; $m &gt; $v)&#123; echo "yes"; &#125;else&#123; echo "no"; &#125; 解析&quot;no&quot;,只要仔细分析就不难得出$l&gt;$m 会转换成1 ，则这个时候再和$m比较。 执行下面代码 $x 会变成什么值呢？题目12345&lt;?php $x = NULL; if('0xFF' == 255)&#123; $x = (int)'0xFF'; &#125; 解析$x=0 而不是255.首先&#39;oxFF&#39; == 255 我们好判断，会进行转换将16进制数字转换成10进制数字，0xff -&gt; 255.PHP使用 is_numeric_string 判断字符串是否包含十六进制数字然后进行转换。但是 $x = (int)&#39;0xFF&#39;; 是否也会变成255呢？显然不是，将一个字符串进行强制类型转换实际上用的是 convert_to_long ,它实际上是将字符串从左向右进行转换，遇到非数字字符则停止。因此 0xFF 到x就停止了。所以 $x=0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC、SPA 与 SSR]]></title>
    <url>%2F2019%2F01%2F16%2FMVC%E3%80%81SPA%20%E4%B8%8E%20SSR%2F</url>
    <content type="text"><![CDATA[这篇的灵感来自於 Front-End Developers Taiwan 裡面的一串讨论，有人 po 了一个影片是来讨论「MVC vs SPA」，这个标题一出来大家都惊呆了，想说怎麼会有这样的比较，於是下面掀起一波激烈的讨论，最后发现原 po 误用了专有名词，才导致这样的结果。 虽然说很多技术名词本来就是一个名词各自表述，但基本概念通常都不会相差太远，只有在细节上会有些许的争议以及讨论而已。 身為致力於要让新手更容易搞懂技术名词的人，不如就让我来尝试看看讲解这几个东西吧！ 这篇文章的目标是：「只要你有网页前端的基础，就能够搞懂我在说什麼」，如果你搞不懂的话，别担心，不是你的错，是我没写好。麻烦在下面留言一下让我知道哪裡可以再改进。 接下来我会以主角小明為中心点出发，试著从一段虚拟的故事不断带出：「為什麼 XXX 会出现」、「為什麼我们需要 XXX」这些问题。如果你只对真实歷史的名词演进有兴趣，那你可能要去维基百科才能找到比较正确的资料。本故事纯属虚构，如有雷同…应该不太可能会有雷同啦，就让我们开始吧！ （先打个预防针，故事有点长，如果这些概念你都理解了应该会觉得这篇文章超级废又超级长） 第一幕：在很久很久以前…小明是一个初学程式的新手，在这之前有用 Dreamweaver 写过一些简单的静态网页，对 HTML、CSS 以及 JavaScript 都有一些基础，而朋友们都推荐他去学 PHP 来补足后端的部分。 经过了一个月的苦练之后，小明终於完成了他的第一个后端程式，是一个非常简单的留言板系统（怕大家伤眼睛，这边只截给大家看其中一部分） 别笑，这就是你年轻时会写出来的东西 PHP 程式码、商业逻辑、HTML，全部东西都混在一起做撒尿牛丸，写了这样的程式码之后，小明每次考试都考一百分呢！ 小明一开始觉得很兴奋，自己终於能够通晓前后端，成為全端工程师，便兴冲冲的持续精进自己的后端技术，每天都加一个新的 feature 进去。过了两个礼拜之后，小明整理了一下资料夹，发现总共有 100 个 PHP 档案，每个档案有超过 300 行 code，而且全部都是 PHP 跟 HTML 混在一起写。 他随便点开其中一个档案，看了 10 秒之后大喊： 我到底写了三小 意识到自己写的 code 很烂，是迈向一个好的工程师的第一步。 第二幕：痛改前非发现自己写的程式码连自己都看不懂的时候，小明觉得这样不行，阿岳也觉得不行，我也觉得不行。 因此呢，小明跑去十分瀑布下面打坐了三天三夜，不断想著该怎麼样让他的程式码变得更好，能够更好维护、更好读懂。他不求一步登天，只希望三个月之后当他回顾自己写的 code 时，不要骂脏话就好。 就在第三天的晚上，他突然有了灵感，大喊了一声： Eureka！ 就赶紧跑回家去重构自己的 code 了，而下面是他重构的结果： 纯属范例，绝对没办法跑 这个范例跟之前差在哪边呢？ 首先，他把任何跟资料有关的操作都放到一个叫做 Model 的地方去，所以你要改任何跟资料有关的东西，都到那边就对了。 再来，他也把所有跟显示画面有关的东西都放到其他地方去，我们就叫做 View 吧，View 裡面用一个 template 来塞入资料，不做任何跟资料有关的处理。 如此一来，他就把资料跟画面显示这两者切开了，并且让开头那段 PHP code 把这两者连接起来，先去 Model 拿资料，再把资料塞入 View 裡面输出。那这个「连接两者」的角色，就叫做 Controller 吧！ 於是，MVC 就这样出现了。為的就是要把原来乱七八糟的程式码理出一个头绪来，是你的就是你的，不是你的就给我滚远点。你要存取资料库就是去 Model 裡面，你要写 HTML 就去 View，绝对不会出现在 View 裡面下 SQL Query 这种事情。 所以 MVC 是什麼？就是一种设计模式，你只要把你的 code 像这样子切开，都可以叫做 MVC，所以你不可能只看一个画面就跟你朋友说：「欸欸，这个网站是 MVC，因為他有好多个页面」，除非你可以通灵看到背后程式码的架构长什麼样子。 话说后来又陆陆续续出现很多种模式，而且 MVC 其实也没有想像中的职责这麼分明，在这边我就不细讲了，我自己对那整段歷史也没有很熟，有兴趣的可以参考： MVC是一个巨大误会_我是web工程师，从刚开始学MVC就深感困惑： 怎麼每个地方说的MVC都不太一样？ 有些文章讲的MVC，跟我正在用的MVC，怎麼像完全不同的东西？…_blog.turn.tw 然后我上面那段 code 是乱写的，如果你对真实世界的 MVC 框架写出来的 code 有兴趣的话，会长成这样： PHP 的框架 CodeIgniter 写出来的 讲到这裡我们做一个小总结，问自己三个问题： 為什麼要有 MVC？ 有 MVC 跟没有 MVC 的差别在哪？ 所以 MVC 是什麼？ 三个问题可以一起回答： 因為小明写的 code 太脏了太难维护，所以需要重构。而后来他发现用 Model、View、Controller 这三个概念来切的话可以把 code 写得漂亮很多又好维护，就这样做了。差别在於原本的 code 混在一起，遵守 MVC 的规范之后职责变得清楚很多。所以呢，MVC 就是一种架构，后端可以遵守 MVC 的架构去开发，前端也可以，就算不是 Web 也可以用 MVC。 第三幕：毛很多的使用者小明把自己的烂 code 利用 MVC 模式重构之后，看起来还挺不赖的，至少比以前好很多，三个月过去了，也能看得懂自己以前写的 code。把留言板的程式码重构得差不多之后，小明决定把这个专案公开，开放给大家註册使用，让每个人都可以有自己的留言板。 一开始状况都还行，大家纷纷感激小明的无私奉献，「祝楼主一生平安」、「感谢大大无私的分享」，可是好景不常，有天小明收到了一个回馈： 我每次留言之后页面都会刷新，我家网速又慢，每次都要等个十几秒，有没有可能不要重新整理页面？你看人家 Gmail，我寄完信它也没有重新整理啊！人家做得到你应该也做得到吧 身為一个滥好人，小明乖乖的去研究 Gmail 到底是如何做到的，发现秘诀就在於一个神奇的东西：Ajax，全名 Asynchronous JavaScript and XML。 全名听起来很吓人，但说穿了其实就是你在 JavaScript 裡面可以非同步的去呼叫 Server 的 API 并且拿资料回来，在 Ajax 出现之前，你要把资料带过去都必须透过 Form 的方式，一定要换页。可是有了 Ajax 以后，不换页也能跟 Server 沟通。 Gmail 就是利用这样的原理，才能达成寄信不换页。 小明研究了一个假日之后便著手改造自己的留言板，把原本利用 Form 发送留言的地方变成 Ajax，可是他碰到了一个问题： 原本我新增留言之后重新整理页面就可以看到新的留言了，因為 Server 会把最新的结果传回去；可是我现在用 Ajax，我要怎麼在不刷新页面的前提下在画面上新增留言？ 总而言之呢，利用 Ajax 之后的确是发了一个 Request 跟 Server 说你要新增留言，也成功了，可是画面上不会平白无故就跑出一个新的留言。在经过短暂的思考后，小明得到一个很直觉的解法：「阿我就用 JavaScript 来新增就好啦！」 经过一番修改之后，新增留言的程式码从原本很简单的一个 Form 表单，变成下面这个样子： Ajax 送出资料之后利用 jQuery prepend 上去 使用者的需求被解决了，小明也有了技术上的成长，可谓是一石二鸟、一举两得，但小明天真的地方就在於他把使用者想得太简单了。 过了一个礼拜之后，同一个使用者又写信给小明： 很感谢你上次新增的功能，可是我有个疑问。我看 Gmail 无论做什麼操作都不会换页，你的留言板也可以改成这样吗？这样比较方便，谢谢。 滥好人小明没有仔细深究「比较方便」到底是怎样的方便，纯粹站在一个希望满足使用者所有需求的角度跳下去研究 Gmail 到底还能够做到什麼。 他发现了 Gmail 跟其他网站不同的地方就是：「无论做什麼操作都不会换页」，换页指的是「你会有一段时间看到整个画面全白，因為瀏览器正在等待 Server 的 Response 才能载入 HTML」。 你在用 Gmail 的时候，无论你是写信、读信、整理信件或是切换到设定页，儘管你的网路跟乌龟一样，你还是看不到任何全白画面。 為什麼？因為 Gmail 所有跟 Server 沟通的地方都是用 Ajax。 这是改造前的范例，我们利用表单 POST 来新增一笔留言，所以你会看到一小段的白画面： 此范例改自我学生 Kris 的作业，http://thinkr.tw/ 这是改造后的范例，因為我们用 Ajax 来新增留言的关係，所以你不会看到任何白画面的出现，使用者体验好很多： 利用 Ajax 跟 JavaScript 在前端新增留言 我们再举一个简单的小例子，假设小明今天写了一个没有用 Ajax 的 Minmail，他删除一封信的流程是这样的： 点击删除之后，利用 Form 表单 POST 资料去 /server/delete_email /server/delete_email 处理完之后 redirect 回去信件列表 瀏览器重新载入信件列表（在载入之前你都会看到全白画面） 可是如果是像 Gmail 那样子全部改成 Ajax 的话，就会变成： 点击删除之后，利用 Ajax POST 资料去 /server/api/delete_email /server/api/delete_email 处理完之后回传 Response 利用 JavaScript 在前端把那封信的从画面上移除 后者利用 Ajax 跟后端同步资料，并且在前端用 JavaScript 更改画面，所以你无论做什麼操作都不会换页，也可以保证前后端的资料是同步的。 知道区别以及原理之后，小明把整个网站都改造成这种形式，只要是任何原本用到 Form 的地方，现在全部都用 Ajax 拿资料并搭配 JavaScript 来做画面上的处理。 因此，留言列表现在变成 Ajax 拿资料回来之后由 JavaScript 把留言 append 到画面上，就像我们刚刚示范的新增留言那样。 此时，小明突然有个非常惊人的发现： 咦，如果我全部画面都是由前端利用 JavaScript 动态產生的话，那我原本后端的 View 要干嘛？ 咦，对啊，既然现在所有画面都是在前端由 JavaScript 动态產生，那我后端不就永远都输出同一个档案就好？如此一来，使用者看到的其实都是同一个页面，而我们利用 JavaScript 在这个页面上做变化。 这个概念就叫做 SPA，全名是 Single Page Application，单页式应用。与之对应的概念是 MPA，Multiple Page Application。 SPA 与 MPA 的对照 就如同小明领悟的一样，前端如果利用 SPA 来实作的话，会把原本应该是后端处理的一部份职责给搬到前端去，例如说状态的管理跟路由。 举例来说，在以往 Server 根据不同的路径对应到不同的 Controller，进而渲染出不同的 View。可是现在 Server 无论什麼路径都会输出同一个档案，所以你在前端也要判断现在的网址是哪个，才能决定在前端应该渲染出哪个画面。 再举一个例子，假设我现在写了一个电影列表的网站，首页列出许多热门电影，点进去可以看到个别电影的详细资料。而我们做了以下动作： 点进电影 A 快速按上一页 快速点进电影 B 如果是 SPA 的话，实作的逻辑应该会是：「点进单独电影时发送一个 Request，等 Response 回来之后把资料显示在画面上」，乍听之下没什麼问题，但若是你在第三步的时候，第一步所发出去的电影 A 的 Response 才传回来，你的画面就会显示出电影 A 的资讯，可是使用者点的明明就是电影 B。 这就是我所说的状态管理变复杂了，有些地方需要花点心思做处理。在以往 MPA 的时候完全不会发生这种事，你可以保证 Server 会回传正确的结果，因為画面是在后端 render 再回传回来的，而且每一个页面之间的状态不会互相干扰。 如果写得好，我相信 SPA 的使用者体验一定很不错，因為用起来就跟你在用 Native App 差不多嘛，但你必须付出的代价是前端变得超级复杂，有一堆非同步的问题要考虑还有一大堆事情要做。此时的前端复杂度已经跟我们最开头示范的那种简单留言板相差许多了。 在这种时候，前端也可以参考我们前面所说的 MVC 架构或是其他相关架构来让程式码的职责变得更分明，让整个专案更好维护。所以你可以又有 MVC 又有 SPA，或是没有 MVC 但有 SPA，这两者是完全不同的概念。 我之前写过另外一篇文章，有兴趣的话可以参考看看： 前后端分离与 SPA_TechBridge Weekly 技术週刊团队是一群对用技术改变世界怀抱热情的团队。本技术共笔部落格初期专注於Web前后端、行动网路、机器人/物联网、数据分析与產品设计等技术分享。_blog.techbridge.cc 最后我举一个一定要用 SPA 的例子：音乐播放网站。 如果音乐播放网站是用 MPA 的话，每去一个新的网址就会把整个页面换掉，那你的网页播放器就会中断了，这是完全没办法接受的事。所以唯一的解法就是：播放器永远都在页面上，只有其他部分的内容换掉。而这一切都是在前端用 JavaScript 来处理的。 第四幕：行销团队的暴怒小明花了整整一个月的时间不眠不休不吃不喝（夸饰法，开玩笑的），终於把整个网站改造成 SPA，而且还优化了不少地方，让整个使用者体验变得非常非常好。 不久过后，这个留言板系统因為体验实在是太好了，有越来越多人使用，短短一个月内就有了一百万个来自世界各地的使用者註册。还有来自国外的使用者甚至写信给小明希望能够付钱来拥有更多功能： Hey, thanks for building such a cool website, I really like it. Is there any premium plan? I am glad to pay for the additional features like custom domain or custom template. 听过一大堆创业讲座的小明知道时候到了，可以把这个 side project 当作创业项目了！ 凭著现有的成绩，小明很快地就募到了天使轮，找了几个伙伴成立了一间公司，想要把这个留言板系统做成全世界第一的留言板，期许自己能成為留言板界的 WordPress。 可是好景不常，过了一两个月之后不知道為什麼，新的会员越来越少，砸下大笔的广告费也只带来短暂的成效而已，一旦广告停了就又恢復以往冷清的样子。 奇怪，就算是热潮退烧也没退烧得这麼快才对，到底是发生什麼事呢？ 一个礼拜过后，专长是数位行销的合伙人气噗噗的跑到小明的位子前，口气很差地质问他： 你做了什麼？為什麼在搜寻引擎上面搜寻我们的网站，结果只会出现一大堆看不懂的程式码？我们的网站 SEO 做的奇差无比你知道吗？ 小明一开始觉得很委屈，他什麼都没做，怎麼会落得如此下场。但经过左思右想之后，终於发现了癥结点：SPA。 由於 SPA 是由前端的 JavaScript 动态產生内容，因此如果你对 SPA 的网站按下右键 -&gt; 检视原始码，只会看到空荡荡的一片，只看得到一个 JavaScript 档案跟一些最基本的 tag。 内容在哪裡？不在这裡，因為那是由 JavaScript 动态產生的。只有你的网站经由瀏览器载入并且执行 JavaScript，等 Response 回来之后才会动态產生出内容。因此无论是哪个页面，你检视原始码都看不到动态新增后的内容。 惨了，这可是天大的坏消息。 但其实也没有那麼坏，因為强大的 Google 的爬虫其实支援执行 JavaScript，所以他依然会 index 你在前端渲染之后的页面。 不过还是有两个问题，第一个是我们不知道 Google 如何执行，会不会前端还没完全渲染完就已经爬完了？第二个是除了 Google，还有其他很多搜寻引擎，有些可能没有像 Google 这麼强大，碰到 SPA 就只能索引空荡荡的 HTML，内容几乎空白。 该怎麼办呢？ 苦恼的小明跟公司请了长假，再度跑到十分瀑布下面修行，希望能够重演当年想出 MVC 架构的剧本。很幸运地，过了三天之后，小明终於想到解法了，大喊了一声： 干我知道了！ 小明的想法是这样的，既然问题出在「第一次渲染」，那我们只要在第一次渲染的时候把该输出的资料都输出就好啦，对使用者来说还是一个 SPA，差别在於使用者接收到 HTML 的时候，就已经有完整的资料了。 举例来说，假设使用者拜访显示所有留言的页面，我在 Server Side 先把所有留言都準备好然后 render 出来，这样使用者一收到 Response 的时候就能够看到所有留言，搜寻引擎也能顺利地爬到。 而后续的操作还是由 JavaScript 来处理，依旧能保持 SPA 的优点。或者我们能用一句话来总结： 第一个页面由 Server side render，之后的操作还是由 Client side render 没错，这个概念就叫做 SSR，Server Side Rendering。 CSR vs SSR 有了 SSR 以后，就解决了 SEO 的问题，对网路爬虫来说你有没有用 SPA 都无所谓，他所抓到的内容都是一样的。可是对使用者来说，一样能享受到 SPA 所带来的好处（不用换页）。 虽然我在这边只用几句话带过去，看起来轻鬆写意，但真的实作过的话你就会发现这不是一件容易的事，有很多细节要去考虑。总之呢，小明花了整整两个月的时间才把整个网站都改成 SSR。 不久后，在每个月的员工大会（新创嘛，一个月一次很合理）中 CMO 很开心地跟大家宣布產品在搜寻引擎上面的排名越来越高，自然流量也越来越多，註册会员比起上个月增长了 200%。 CMO 很开心，搜寻引擎很开心，员工很开心，小明当然也很开心。 一天又平安的过去了，感谢飞天小明警的努力。 最终幕：前端的未来因為科技进步快速加上网路的普及，世界变动的比以前快很多。 十年前手机还只是让你打电话以及斤斤计较简讯字数的工具，十年后就变成人手一台，不可或缺的小型电脑。 身為经歷过这一切的人，小明在深夜裡边刷著 leetcode 边回忆起前端的发展，遥想十年前他以為 HTML 跟 CSS 才是主角，JavaScript 只是阻止使用者点右键或是做出会跟著鼠标移动的酷炫跑马灯的小玩具。 可是一切发展的越来越快，jQuery 的出现一统江湖，解决了恼人的跨瀏览器问题，CSS 也因為预处理器的出现而变得更好维护，可以用更程式化的角度来撰写。再过个两三年，大家都不谈 jQuery 了，而是谈 Angular。可是又过了几年，最潮的名词变成 React，到现在 React 也没那麼潮了，要潮的话请去写 Vue。 更别提 SPA 的遍地开花以及 SSR 的出现，更是将前端的复杂度提升了不只一个档次。有了 SSR 你就不再只是前端了，毕竟 SSR 的 S 可是 Server 的意思，还必须要会一点 Server side 的技术才行。 在 Mobile 的流量渐渐超越 Desktop 之后，前端的目标就迈向「可以逼近 Native App」的体验。又像是个 App 可是又不用安装，那该有多好，省了安装这个步骤转换率大幅提升，使用者开心公司也开心。 於是大家开始提倡 PWA，Progressive Web App。Web 不再单纯只是 Web，而是要用起来像个 App，看起来也像个 App。甚至利用 Service Worker 搭配快取，在没有网路时也能够使用部分功能，也可以用 Skeleton 先把画面的骨架显示出来。 这一切的一切都為了一个目的：增进使用者体验。 前端复杂归复杂，但身為真心喜爱前端的人，小明可是对未来充满了希望。一想到能够接触更多新的技术，更多新的解法，可以打造出更好的產品，小明内心涌起的情绪不是挫折而是兴奋，无比的兴奋。 东方的太阳缓缓升起，散射出的光芒洒在小明的房裡，提醒著他新的一天即将开始。 结语对我来说，一个技术的出现绝对是有其理由的。而不是简单一句：「前端现在就是这麼复杂」，我认為只要能理解他出现的脉络，就能更轻易的从宏观的角度去理解这项技术。 我们可以用三个问题来帮助自己理解一项事物： 為什麼要有 XXX？ 没有 XXX 跟有 XXX 的区别是什麼？ 所以 XXX 是什麼？ MVC 就是因為 code 变得越来越乱，所以将职责区分清楚的一种设计模式。SPA 就是因為想增进使用者体验，而出现的一种在前端利用 Ajax 达成不换页的方法。SSR 就是因為要解决 SPA 的 SEO 问题而出现的解法。 一切都是有理由的，一切都是有原因的。你可以不懂它怎麼实作，但你一定要懂它是為了什麼而生。程式是工具，工具的目的是解决问题，重要的不是工具本身，而是背后要解决的那个问题。 感谢大家的阅读，如果有任何错误麻烦不吝指出。另外，此篇文章只希望能给出一个大方向，对於细节如果要讨论的话其实每个细节都可以再写一篇专文，例如说 MVC 到底是在讲哪个 MVC？SPA 在 Google 上的 SEO 真的比较差吗？SSR 在首次加载页面上牺牲的时间（因為要等 API 的资料回来才能 render）与增进 SEO 之间的取捨等等。 喜欢的话可以拍个手，你知道 Medium 最多可以拍 50 下吗？可以根据你的喜好程度拍不同次数的手，想要拍好拍满的话我也是乐见其成。 最后，再次感谢你的阅读。 Frontend Front End Development Technology JavaScript Single Page Applications 转载说明此文章是在一技术讨论群里看到的，看后觉得很有感悟，便转载了过来，但当时只是把内容复制了过来，原文的链接忘了，后来找了群里面的聊天记录和浏览器的访问历史，都没有找到，在此就不注明原文章的链接了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git多分支平行发展（一个仓库包含多个不同的项目）]]></title>
    <url>%2F2018%2F06%2F29%2FGit%E5%A4%9A%E5%88%86%E6%94%AF%E5%B9%B3%E8%A1%8C%E5%8F%91%E5%B1%95%EF%BC%88%E4%B8%80%E4%B8%AA%E4%BB%93%E5%BA%93%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景最近在用laravel开发微信小程序的接口，因为服务器PHP版本的问题，分别用了laravel 5.6(php 7.1，开发环境) 和 laravel 5.4 (php 5.6，服务器环境)，开发完成后，两个项目绝大部分的代码都差不多，不想再建一个仓库放php 5.6版的代码，便试着在原有仓库新建分支来存储php 5.6的项目，捣鼓的一上午终于搞出来了，现在记录下。 主要步骤： 在远程和本地仓库中新建一个分支（我建的是laravel54）； 删除远程laravel54分支上的所有文件； 将新项目的文件推送到laravel54上。 文章中的代码没有高亮化，看着可能不太舒服，其他平台地址：segmentfault 简书 流程新建一个文件夹(我的是laravel5.4)创建git本地仓库并关联远程仓库123456沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4$ git initInitialized empty Git repository in D:/PHP/xampp/htdocs/apple/laravel5.4/.git/沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git remote add origin git@xxxxxxxxxxxxxxxxxxxxx.git 建立远程仓库分支 laravel54注意，建立远程分支后，暂时还不能在本地建立其他分支，因为刚创建的git仓库默认的master分支要在第一次commit之后才会真正建立，这时创建其他分支会报错，解决办法在后面说明。 123沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git branch laravel54fatal: Not a valid object name: &apos;master&apos;. 随便新建一个文件，里面可以不用写任何东西，然后commit1234567891011沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ touch clearTheBranch沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git add clearTheBranch沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git commit -m&apos;clean this branch&apos;[master (root-commit) c7c5349] clean this branch1 file changed, 0 insertions(+), 0 deletions(-)create mode 100644 clearTheBranch 推送之前先更新（下面的代码是最核心的代码）新建的分支默认与master分支一样，所以要在推送之前先把分支上的内容拉下来。 1234567891011121314沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git pull origin laravel54warning: no common commitsremote: Enumerating objects: 2453, done.remote: Counting objects: 100% (2453/2453), done.remote: Compressing objects: 100% (2320/2320), done.Receiviremote: Total 2453 (delta 1547), reused 229 (delta 89)Receiving objects: 100% (2453/2453), 1.40 MiB | 1.38 MiB/s, done.Resolving deltas: 100% (1547/1547), done.From xxxxxxxxxxxxxxxxxxxxx * branch laravel54 -&gt; FETCH_HEAD * [new branch] laravel54 -&gt; origin/laravel54fatal: refusing to merge unrelated histories 这个时候会报错，是正常现象，，原因是本地仓库和远程仓库不一样，有类似两者有完全不相同的commit历史，只需要在在pull的同时加上一行代码即可，代码如下： 123456沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git pull origin laravel54 --allow-unrelated-historiesFrom xxxxxxxxxxxxxxxxxxxxx * branch laravel54 -&gt; FETCH_HEADMerge made by the &apos;recursive&apos; strategy.... 这步操作的时候，会有merge的commit说明，简单写下，这个只是merge的说明，并不会真正和mater合并。经过这一步操作，就已经把远程仓库laravel54分支里面的文件都拉下来了，接下来建立与远程仓库对应的本地分支。 建立并切换到本地分支 laravel541234567891011沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git branch laravel54沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git checkout laravel54Switched to branch &apos;laravel54&apos;沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$// 也可以直接用 git checkout -b laravel54 删除本地仓库里的所有文件（除了.git的文件夹），然后推送1234567891011121314151617181920沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git add .沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git commit -m&apos;delete all files&apos;[laravel54 d8bf12d] delete all files215 files changed, 32019 deletions(-)...沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git push origin laravel54Enumerating objects: 7, done.Counting objects: 100% (7/7), done.Delta compression using up to 4 threads.Compressing objects: 100% (4/4), done.Writing objects: 100% (6/6), 683 bytes | 341.00 KiB/s, done.Total 6 (delta 1), reused 1 (delta 0)remote: Powered by Gitee.comTo xxxxxxxxxxxxxxxxxxxxx.git c810298..d8bf12d laravel54 -&gt; laravel54 这个时候，远程仓库的laravel54分支便和本地仓库的laravel54分支一样都是空白的，这样就可以随心所欲的推送了。 新项目推送这时就可以把之前的项目拷进这个文件夹里面，然后按照正常的推送流程进行推送。 1234567891011121314151617181920212223242526沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git add .warning: LF will be replaced by CRLF in .env.example.The file will have its original line endings in your working directory....沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git commit -m&apos;laravel54 push&apos;[laravel54 eba0954] laravel54 push 113 files changed, 11583 insertions(+) create mode 100644 .env.example create mode 100644 .gitattributes ...沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git push origin laravel54Enumerating objects: 152, done.Counting objects: 100% (152/152), done.Delta compression using up to 4 threads.Compressing objects: 100% (126/126), done.Writing objects: 100% (151/151), 211.43 KiB | 2.94 MiB/s, done.Total 151 (delta 14), reused 42 (delta 4)remote: Resolving deltas: 100% (14/14), done.remote: Powered by Gitee.comTo xxxxxxxxxxxxxxxxxxxxx.git d8bf12d..eba0954 laravel54 -&gt; laravel54 小总结不用担心推送错分支导致分支合并经过如上操作，就可以实现master分支和laravel54是两个完全不同的项目，可以保持两个项目平行发展，因为两个分支的提交历史不一样，所以即便是误操作，提交错了分支，git会给出相应的报错，不会把两个分支直接合并，下面是代码演示： 本地laravel54向远程master分支推送 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ touch a.txt沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git add a.txt沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git commit -m&apos;test file a.txt&apos;[laravel54 e246705] test file a.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 a.txt沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git push origin masterTo xxxxxxxxxxxxxxxxxxxxx.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;git@xxxxxxxxxxxxxxxxxxxxx.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.//本地版本回退沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git logcommit e246705e9894a658d3fb2ea8f51b1ee0dd8ff834 (HEAD -&gt; laravel54)Author: muyan &lt;xiao7shuang@qq.com&gt;Date: Fri Jun 29 14:50:35 2018 +0800 test file a.txtcommit eba09541b60e496127f6280c3db9611f72504744 (origin/laravel54)Author: muyan &lt;xiao7shuang@qq.com&gt;Date: Fri Jun 29 14:36:48 2018 +0800 laravel54 pushcommit d8bf12d9df1337f9f7e0de723608796a490f66dcAuthor: muyan &lt;xiao7shuang@qq.com&gt;Date: Fri Jun 29 14:24:02 2018 +0800 delete all filescommit dcfb2b00f4f8ad0f1f672cde9b9e9ddc79d85239 (master)Merge: c7c5349 c810298Author: muyan &lt;xiao7shuang@qq.com&gt;Date: Fri Jun 29 13:56:24 2018 +0800 Merge branch &apos;laravel54&apos; of xxxxxxxxxxxxxxxxxxxxx for claering the branchcommit c7c5349779f868fbc1cf18d742d634c9d3267c32Author: muyan &lt;xiao7shuang@qq.com&gt;Date: Fri Jun 29 13:55:01 2018 +0800 clean this branch沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git reset eba09541b60e496127f6280c3db9611f72504744 //回退到上一次提交之前的版本沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (laravel54)$ git statusOn branch laravel54Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) a.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 本地master分支向远程master分支推送 12345678910111213141516171819沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git add a.txt沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git commit -m &apos;test file a&apos;[master d3e8bba] test file a 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 a.txt沐@ MINGW64 /d/PHP/xampp/htdocs/apple/laravel5.4 (master)$ git push origin masterTo xxxxxxxxxxxxxxxxxxxxx.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &apos;git@xxxxxxxxxxxxxxxxxxxxx.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 理论上可以实现无限平行分支，同样若一个项目中有版本（稳定版、开发版等），也可以跟据此思路扩展。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的小算法（PHP版）]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%B0%8F%E7%AE%97%E6%B3%95%EF%BC%88PHP%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本文主要记录一些在工作、生活中遇到的有趣的算法，旨在用简单的代码给出过程和答案（基于目前编程水平的理解），不定期更新。 打印函数封装为打印数据方便，简单自定义一个打印函数。 12345678910111213141516171819202122/** * format and output array,string, supporting objects * * @param mixed $print * @param string $show * @param bool $need */function pp($print,$show = 'pp',$need = false)&#123; echo '&lt;div style="border: 1px solid bisque;border-bottom-color:red;border-right-color:red;color:green;background-color: bisque;"&gt;&lt;pre&gt;'; if($need &amp;&amp; is_object($print))&#123; $print = json_decode($print); &#125; if($show === 'pp')&#123; print_r($print); &#125; if($show === 'var')&#123; var_dump($print); &#125; echo '&lt;/pre&gt;&lt;/div&gt;'; &#125; “约瑟夫手环”故事背景一群人排成一圈，按1,2,…,30依次编号。然后从第1个开始数，数到第7个把他踢出圈，从他后面再开始数，再数到第7个，在把他踢出去，如此不停的进行下去，直到最后个剩下一个人为止，求出最后剩下的那个人是谁。 代码12345678910111213$arr = range(1,30);$num = 0;while(count($arr) !== 1)&#123; foreach($arr as $k =&gt; $v)&#123; $num++; if($num % 7 === 0)&#123; unset($arr[$k]); $num = 0; &#125; &#125;&#125;pp($arr); 思路说明 解题关键点是不能被编号为1到30的人所迷惑，最直接的办法就是如上：设置一个变量，让他从零自增，自增到7再重新赋值为0，每次这个变量的值为7的时候，便把数组中循环了7次时对应的键删掉，核心逻辑就这么多； unset($arr[$k]);不能替换成unset($v)，unset($v)这只是把$v这个数字删除掉，但并没有把数组中这个值对应的键删掉。 封装12345678910111213141516function theLastOne($peopleCount,$remove)&#123; $arr = range(1,$peopleCount); $num = 0; while(count($arr) !== 1)&#123; foreach($arr as $k =&gt; $v)&#123; $num++; if($num % $remove === 0)&#123; unset($arr[$k]); $num = 0; &#125; &#125; &#125; return $arr;&#125;pp(theLastOne(30,7)); 关于分钱的问题问题描述将10000块钱分成5份，且每一份之间的相差的值$d不一样，并且相差$d得大于100。 代码及调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 判断数组内是否有差值相等function check_diff($arr)&#123; if(empty($arr))&#123; return false; &#125; $arr = array_map('intval',$arr); sort($arr); $count = count($arr); $diff_arr = array(); for($i = $count - 1;$i &gt;= 0;$i--)&#123; for($j = 0;$j &lt; $count;$j++)&#123; if($arr[$i] &lt;= $arr[$j])&#123; continue 2; &#125; $diff_arr[] = $arr[$i] - $arr[$j]; &#125; &#125; return count($diff_arr) === count(array_unique($diff_arr));&#125;// 主要处理逻辑function process($sum = 10000,$diff = 100,$count = 5)&#123; $return = array(); $i = 1; while($i &lt; $count)&#123; // 随机数不符合要求时的结果初始化 if(isset($return[$i]) || isset($return[$i + 1]))&#123; unset($return[$i],$return[$i + 1]); &#125; $remain_sum = $sum - array_sum($return); // 剩余数 $remain_count = ($count - count($return)); // 剩余需要随机的个数 $min_diff = $remain_count * ($remain_count - 1) * (2 * ($remain_count - 1) + 4) / 12 + ($remain_count * ($remain_count - 1) / 2) * $diff;// 高斯求最小差值和，分两部分：S = n(n+1)(2n+4)/12 + $diff * ((n-1)(n-2)/2) $min = $i === 1 ? 1 : $return[$i - 1] + $diff + 1; // 随机范围的最小值 mt_srand((double)microtime() * 1000000);// 在范围内获取随机数 $rand_max = (int)(($remain_sum - $min_diff) / $remain_count); // 随机范围的最大值 $min = random_int($min,$rand_max); // 产生随机数 $return[$i] = $min; // 放入返回的数组 if($i === $count - 1)&#123; $return[$i + 1] = $remain_sum - $min; // 最后一个随机数直接取总数减去前面的随机数 &#125; if(check_diff($return) === false)&#123; $i--; continue; &#125; $i++; &#125; return $return;&#125;pp(process()); 思路说明问题链接 更新时间：2018-05-31 15:30]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win下MySQL 8.0.11的安装、修改密码、开启远程访问]]></title>
    <url>%2F2018%2F05%2F11%2FMySQL-8-0-11%E7%9A%84%E5%AE%89%E8%A3%85%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E3%80%81%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[昨天匆匆安装了MySQL，并修改了密码、开启远程访问，现在记录分享下，希望对你能有所帮助。安装环境：win server 2012 R2MySQL版本：8.0.11 zip免安装版 下载地址 下载后，进行解压，我的目录为：D:\APP\MySQL 新建配置文件 my.ini，内容如下：12345678910111213141516171819[Client]port = 3306 [mysqld]port = 3306basedir=D:/APP/MySQLdatadir=D:/APP/MySQL/datamax_connections=200character-set-server=utf8default-storage-engine=INNODBsql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES#忘记密码时使用#skip-grant-tables#设置协议认证方式default_authentication_plugin=mysql_native_password[mysql]default-character-set=utf8 设置环境变量以管理员身份运行 cmd 否则可能会出现权限不足的问题，下列操作均在cmd中运行安装并启动MySQL服务mysqld --install 返回结果为 Service successfully installed net start MySQL 或在服务中启动mysql服务 安装mysqld --initialize-insecure这个命令在运行时，光标一直闪，表示正在安装中，直到cmd可以进行输入，即是安装完成；我看别人有这样安装的：mysqld --initialize --console两者的区别是上面这个会展示安装过程并生成一个默认的数据库密码，而我用的方法，不展示安装过程，默认密码为空。 设置密码123use mysql;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;111111&apos;;FLUSH PRIVILEGES; 这期间还涉及MySQL的密码认证插件是mysql_native_password，而现在使用的是caching_sha2_password。 因为当前有很多数据库工具和链接包都不支持caching_sha2_password，为了方便，我暂时还是改回了mysql_native_password认证插件。 在MySQL中执行命令： ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;;修改密码验证插件，同时修改密码。 如果想默认使用mysql_native_password插件认证，可以在配置文件中配置default_authentication_plugin项，这个在新建my.ini中已经设置过了。 参考链接 12[mysqld]default_authentication_plugin=mysql_native_password 开启远程访问123CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;111111&apos;;GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos;;ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;111111&apos;; 在网上看到了两种开启远程方法的方法：在使用第一种方法时会报这样的错误： 开启远程访问这块还分为root账户的远程访问或者指定某个非root账户，网上有很多，就不说明了。 安装好后，至今还没有什么问题，若你预遇见了问题，欢迎和我交流。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国际坐标转换]]></title>
    <url>%2F2018%2F04%2F28%2FGPS%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[工作中用到国际坐标转百度坐标的方法，根据百度地图提供的api，坐标的转换只能用官方提供的api来进行坐标转换，因数据量大，用接口请求数据会导致数据不能及时处理，所以在网上找了好久，再加上同事的帮助和自己的整理，终于整理出PHP可用的坐标转换。 类文件 Position.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpClass BaiduCoordinate&#123; private $x_PI = 3.14159265358979324 * 3000.0 / 180.0; private $PI = 3.1415926535897932384626; private $a = 6378245.0; private $ee = 0.00669342162296594323; public function gcj02tobd09($a,$b)&#123; $confir = $this -&gt; wgs84togcj02($a,$b); [$a,$b] = $confir; $z = sqrt($a * $a + $b * $b) + 0.00002 * sin($b * $this -&gt; x_PI); $theta = atan2($b,$a) + 0.000003 * cos($a * $this -&gt; x_PI); $gb = number_format($z * cos($theta) + 0.0065,6); $ga = number_format($z * sin($theta) + 0.006,6); return [$gb,$ga]; &#125; public function wgs84togcj02($lng,$lat)&#123; $lng = $this -&gt; latlng($lng); $lat = $this -&gt; latlng($lat); if($this -&gt; out_of_china($lng,$lat))&#123; return [$lng,$lat]; &#125;else&#123; $dlat = $this -&gt; transformlat($lng - 105.0,$lat - 35.0); $dlng = $this -&gt; transformlng($lng - 105.0,$lat - 35.0); $radlat = $lat / 180.0 * $this -&gt; PI; $magic = sin($radlat); $magic = 1 - $this -&gt; ee * $magic * $magic; $sqrtmagic = sqrt($magic); $dlat = ($dlat * 180.0) / (($this -&gt; a * (1 - $this -&gt; ee)) / ($magic * $sqrtmagic) * $this -&gt; PI); $dlng = ($dlng * 180.0) / ($this -&gt; a / $sqrtmagic * cos($radlat) * $this -&gt; PI); $mglat = $lat + $dlat; $mglng = $lng + $dlng; return [$mglng,$mglat]; &#125; &#125; public function out_of_china($lng,$lat)&#123; // 纬度3.86~53.55,经度73.66~135.05 return !($lng &gt; 73.66 &amp;&amp; $lng &lt; 135.05 &amp;&amp; $lat &gt; 3.86 &amp;&amp; $lat &lt; 53.55); &#125; public function transformlng($lng,$lat)&#123; $ret = 300.0 + $lng + 2.0 * $lat + 0.1 * $lng * $lng + 0.1 * $lng * $lat + 0.1 * sqrt(abs($lng)); $ret += (20.0 * sin(6.0 * $lng * $this -&gt; PI) + 20.0 * sin(2.0 * $lng * $this -&gt; PI)) * 2.0 / 3.0; $ret += (20.0 * sin($lng * $this -&gt; PI) + 40.0 * sin($lng / 3.0 * $this -&gt; PI)) * 2.0 / 3.0; $ret += (150.0 * sin($lng / 12.0 * $this -&gt; PI) + 300.0 * sin($lng / 30.0 * $this -&gt; PI)) * 2.0 / 3.0; return $ret; &#125; public function transformlat($lng,$lat)&#123; $ret = -100.0 + 2.0 * $lng + 3.0 * $lat + 0.2 * $lat * $lat + 0.1 * $lng * $lat + 0.2 * sqrt(abs($lng)); $ret += (20.0 * sin(6.0 * $lng * $this -&gt; PI) + 20.0 * sin(2.0 * $lng * $this -&gt; PI)) * 2.0 / 3.0; $ret += (20.0 * sin($lat * $this -&gt; PI) + 40.0 * sin($lat / 3.0 * $this -&gt; PI)) * 2.0 / 3.0; $ret += (160.0 * sin($lat / 12.0 * $this -&gt; PI) + 320 * sin($lat * $this -&gt; PI / 30.0)) * 2.0 / 3.0; return $ret; &#125; public function latlng($lat)&#123; $lat_val = floor($lat / 100); return (($lat / 100) - $lat_val) * 100 / 60 + $lat_val; &#125; &#125; 封装123456789101112/** * 离线百度坐标转换 * @param $gpsx * @param $gpsy * @return string */function gpsPosition($gpsx,$gpsy)&#123; require 'Position.php'; $BaiduCoordinate = new BaiduCoordinate(); $gpsArr = $BaiduCoordinate -&gt; gcj02tobd09($gpsx,$gpsy); return implode(',',$gpsArr);&#125; 测试1234$gpsx = '11712.7609';$gpsy = '3150.1322';$result = gpsPosition($gpsx,$gpsy);var_dump($result); 说明 坐标系说明 百度坐标转换API]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo重装与位置移动]]></title>
    <url>%2F2018%2F03%2F23%2FHexo%E9%87%8D%E8%A3%85%E4%B8%8E%E4%BD%8D%E7%BD%AE%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[之前写过一篇关于Hexo–在另一台电脑上写博客的博文，当时对hexo并不是很熟悉，稀里糊涂搞好后，便匆匆记录了下来。在今天重装的时候，才发现是自己给自己挖坑了，其实无论是换台电脑写博客或者重新安装都很简单，现在详细说明下。 基础环境搭建安装hexo 电脑中已经安装了git和node.js，直接随便找个文件夹在 git bash 中执行 npm install -g hexo-cli，这一步是安装hexo。检测hexo是否成功安装，在 git bash 执行 hexo v 看到hexo的版本号就说明安装成功了。 之后创建本地hexo仓库，hexo init &lt;folder&gt; 也可以cd到目标目录，执行hexo init（这里用blog文件夹做说明 hexo init &lt;blog&gt; 或者新建一个blog的文件夹然后执行 hexo init），这一步文件夹内会生成一些基本的文件，这些都是hexo自动部署的，跟git init 同一个道理。 然后 执行 npm install hexo-deployer-git --save 安装hexo提供的快速方便的一键部署功能，然后改 _config.yml 中最下面的配置文件： 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 至此，全部安装工作已经完成，可以在blog的目录下用hexo s测试是否正常。 ssh生成 若本机中已经有ssh，直接添加到github的ssh里面即可，本地没有话，先生成 ssh-keygen -t rsa -C &quot;qq-email@qq.com&quot; （执行期间会让选择放置ssh的目录和ssh密码），用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到 github的 Add SSH Key，添加完成后用 ssh -T git@github.com若提示 Hi *****! You&#39;ve successfully authenticated, but GitHub does not provide shell access.，这就说明与github连接成功了。 重装和迁移重装 这个概念跟网上说的，如何在另外一台电脑写博客是一个意思，没有很多繁琐的操作，只需要把 source、themes 、 _config.yml 覆盖到 blog 的那个文件夹即可 ，只要hexo环境没问题，hexo的一系列操作都没问题（在第一次hexo d可能会有些慢，耐心等待）。 同样，在新电脑上只要把环境搭建好，只要把两个文件夹一个配置文件覆盖过去，都没问题。 包括在备份时也只需要把这两个文件夹一个配置文件备份好，其他的都不用管了。 迁移 至于说迁移，只要本机的hexo环境没问题，把blog文件夹随便放哪都可以。 总结 折腾了一下午总结出来的： 换系统或者换电脑需要重装 hexo 的时候，只需要在hexo环境搭建好的基础上，只需要把 source、themes 、 _config.yml 覆盖到新的博客目录下即可。 只要本机的hexo环境没问题，把blog文件夹随便放哪都可以。 应该是hexo版本更新了的缘故，hexo d时只能在git bash中执行，其他（window环境）命令行模式都是提示无法获取远程仓库或者没有权限。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP方法精选]]></title>
    <url>%2F2017%2F10%2F16%2FPHP%E5%87%BD%E6%95%B0%E7%B2%BE%E9%80%89%2F</url>
    <content type="text"><![CDATA[这些都是工作中用到的比较常用或者有意思的PHP方法，持续更新中… 显示彩虹字符串12345678910111213function color_txt($str)&#123; $len = mb_strlen($str); $colorTxt = ''; for($i=0; $i&lt;$len; $i++) &#123; $colorTxt .= '&lt;span style="color:'.rand_color().'"&gt;'.mb_substr($str,$i,1,'utf-8').'&lt;/span&gt;'; &#125; return $colorTxt;&#125;function rand_color()&#123; return '#'.sprintf("%02X",mt_rand(0,255)).sprintf("%02X",mt_rand(0,255)).sprintf("%02X",mt_rand(0,255));&#125;echo color_txt('asdfwerwtertsadfsadfwtwer'); 对查询结果集进行排序12345678910111213141516171819202122232425262728293031323334/** +---------------------------------------------------------- * 对查询结果集进行排序 +---------------------------------------------------------- * @param array $list 查询结果 * @param string $field 排序的字段名 * @param string $sortby 排序类型 * asc正向排序 desc逆向排序 nat自然排序 +---------------------------------------------------------- * @return array +---------------------------------------------------------- */function list_sort_by($list,$field, $sortby='asc') &#123; if(is_array($list))&#123; $refer = $resultSet = array(); foreach ($list as $i =&gt; $data) $refer[$i] = &amp;$data[$field]; switch ($sortby) &#123; case 'asc': // 正向排序 asort($refer); break; case 'desc':// 逆向排序 arsort($refer); break; case 'nat': // 自然排序 natcasesort($refer); break; &#125; foreach ( $refer as $key=&gt; $val) $resultSet[] = &amp;$list[$key]; return $resultSet; &#125; return false;&#125; 二维数组按指定的键值排序12345678910111213141516171819202122/* * 二维数组按指定的键值排序 * $array 数组* $key排序键值* $type排序方式*/function array_sort($arr, $keys, $type = 'desc') &#123; $keysvalue = $new_array = array(); foreach ($arr as $k =&gt; $v) &#123; $keysvalue[$k] = $v[$keys]; &#125; if ($type == 'asc') &#123; asort($keysvalue); &#125; else &#123; arsort($keysvalue); &#125; reset($keysvalue); foreach ($keysvalue as $k =&gt; $v) &#123; $new_array[$k] = $arr[$k]; &#125; return $new_array;&#125; php判断手机移动设备访问，返回true是移动设备12345678910111213141516171819202122232425262728293031323334function is_mobile()&#123; // 如果有HTTP_X_WAP_PROFILE则一定是移动设备 if (isset ($_SERVER['HTTP_X_WAP_PROFILE'])) &#123; return true; &#125; // 如果via信息含有wap则一定是移动设备,部分服务商会屏蔽该信息 if (isset ($_SERVER['HTTP_VIA'])) &#123; // 找不到为flase,否则为true return stristr($_SERVER['HTTP_VIA'], "wap") ? true : false; &#125; // 脑残法，判断手机发送的客户端标志,兼容性有待提高 if (isset ($_SERVER['HTTP_USER_AGENT'])) &#123; $clientkeywords = array ( 'nokia', 'oppo', 'xiaomi', 'miui', 'huawei', 'coolpad', 'sony', 'ericsson', 'mot', 'samsung', 'htc', 'sgh', 'lg', 'sharp', 'sie-', 'philips', 'panasonic', 'alcatel', 'lenovo', 'iphone', 'ipod', 'blackberry', 'meizu', 'android', 'netfront', 'symbian', 'ucweb', 'windowsce', 'palm', 'operamini', 'operamobi', 'openwave', 'nexusone', 'cldc', 'midp', 'wap', 'mobile' ); // 从HTTP_USER_AGENT中查找手机浏览器的关键字 if (preg_match("/(" . implode('|', $clientkeywords) . ")/i", strtolower($_SERVER['HTTP_USER_AGENT']))) &#123; return true; &#125; &#125; // 协议法，因为有可能不准确，放到最后判断 if (isset ($_SERVER['HTTP_ACCEPT'])) &#123; // 如果只支持wml并且不支持html那一定是移动设备 // 如果支持wml和html但是wml在html之前则是移动设备 if ((strpos($_SERVER['HTTP_ACCEPT'], 'vnd.wap.wml') !== false) &amp;&amp; (strpos($_SERVER['HTTP_ACCEPT'], 'text/html') === false || (strpos($_SERVER['HTTP_ACCEPT'], 'vnd.wap.wml') &lt; strpos($_SERVER['HTTP_ACCEPT'], 'text/html')))) &#123; return true; &#125; &#125; return false;&#125; 将数组形式的字符串转成数组12345678function strToArray()&#123; //数组形式的字符串 $arr = "array('name'=&gt;'张三','age'=&gt;'16')"; $str = []; eval("\$str = ".$arr.'; '); pp($str); //$str即为数组 pp($str['name']);&#125; 参考链接 取去数组中某age键值小于15的其他数组123456789101112131415$arr = array( array('id' =&gt; 1,'age' =&gt; 11), array('id' =&gt; 2,'age' =&gt; 18), array('id' =&gt; 3,'age' =&gt; 16), array('id' =&gt; 4,'age' =&gt; 19), array('id' =&gt; 5,'age' =&gt; 20), array('id' =&gt; 6,'age' =&gt; 14),);$arrs = array();foreach($arr as $key =&gt; $value)&#123; if($value['age'] &lt; 15)&#123; $arrs[] = $value; //$arrs即是结果 &#125;&#125;pp($arrs); 二维数组排序123456789101112131415161718192021222324/** * 二维数组排序 * * @param array $dataArr 要排序的数组 * @param string $type 排序规则 * @param string $field 根据某个键进行排序 * @return array */function arraySort($dataArr,$type='SORT_ASC',$field)&#123; $sort = array( 'direction' =&gt; $type, //排序顺序标志 SORT_DESC 降序；SORT_ASC 升序 'field' =&gt; $field, //排序字段 ); $arrSort = array(); foreach($dataArr AS $uniqid =&gt; $row)&#123; foreach($row AS $key =&gt; $value)&#123; $arrSort[$key][$uniqid] = $value; &#125; &#125; if($sort['direction'])&#123; array_multisort($arrSort[$sort['field']],constant($sort['direction']),$dataArr); &#125; return $dataArr;&#125; 二维数组去重123456789101112131415161718192021222324252627/** * 二维数组去重 * * @param array $arr 要去重的数组 * @return array */function more_array_unique($arr)&#123; $arr_inner_key = $temp = $arr_after = []; foreach($arr[0] as $k =&gt; $v)&#123; $arr_inner_key[] = $k; //先把二维数组中的内层数组的键值记录在在一维数组中 &#125; foreach($arr as $k =&gt; $v)&#123; $v = implode(',',$v); //降维 用join()也行 $temp[$k] = $v; //保留原来的键值 $temp[]即为不保留原来键值 &#125; $temp = array_unique($temp); //去重：去掉重复的字符串 foreach($temp as $k =&gt; $v)&#123; $a = explode(',',$v); //拆分后的重组 如：Array( [0] =&gt; james [1] =&gt; 30 ) $arr_after[$k] = array_combine($arr_inner_key,$a); //将原来的键与值重新合并 &#125; //ksort($arr_after);//排序如需要：ksort对数组进行排序(保留原键值key) ,sort为不保留key值 return array_values($arr_after);&#125; 过去某一天距今天多少年月日12345678910111213141516171819202122232425262728/** * 过去某一天距今天多少年月日 * * @param string $date1 * @param string $date2 * @return array */function diffDate($date1,$date2)&#123; if(strtotime($date1) &gt; strtotime($date2))&#123; $tmp = $date2; $date2 = $date1; $date1 = $tmp; &#125; list($Y1,$m1,$d1) = explode('-',$date1); list($Y2,$m2,$d2) = explode('-',$date2); $Y = $Y2 - $Y1; $m = $m2 - $m1; $d = $d2 - $d1; if($d &lt; 0)&#123; $d += (int)date('t',strtotime("-1 month $date2")); $m--; &#125; if($m &lt; 0)&#123; $m += 12; $Y--; &#125; return array('year' =&gt; $Y,'month' =&gt; $m,'day' =&gt; $d);&#125; 给字符串中每个元素加单引号1234567891011121314151617181920/** * 给字符串中每个元素加单引号，用于数据库写入 * * @example $str = 'a,b,1,2,3,45,g'; 处理后 $str = "'a','b','1','2','3','45','g'"; * @param string $str 需要处理的字符串 * @param string $delimiter 分隔符 * @return string */function stringArray($str,$delimiter = ',')&#123; if($str !== '')&#123; $arr = explode($delimiter,$str); $new = []; foreach($arr as $item)&#123; $new[] = "'" . $item . "'"; &#125; return implode($new,$delimiter); &#125;else&#123; return $str; &#125;&#125; post请求实例12345678910111213141516171819202122232425262728293031/** * 卡斯达特指令下达 * @param $ip string IP * @param $port string 端口号 * @param $card string 车牌号 * @param $devid string 设备ID（全小写） * @param $pwd string 密码 * @param $cmd string 指令 * @return array */function carstart_send_order($ip,$port,$card,$devid,$pwd,$cmd)&#123; $url = 'http://www.baidu.com'; $data = array( 'ip' =&gt; $ip, 'port' =&gt; $port, 'carNumber' =&gt; $card, 'devideId' =&gt; $devid, 'password' =&gt; $pwd, 'cmd' =&gt; $cmd, ); $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,10); curl_setopt($ch,CURLOPT_POST,1); curl_setopt($ch,CURLOPT_POSTFIELDS,$data); $file_contents = curl_exec($ch); curl_close($ch); return $file_contents;&#125; 编码类函数检测字符编码类型123function codeType($str)&#123; return mb_detect_encoding($str,array("ASCII",'UTF-8',"GB2312","GBK",'BIG5'));&#125; 编码转换123456789101112131415161718192021222324//gb2312转utf8function gbkToUtf8($str)&#123; return iconv("GB2312","UTF-8",$str);&#125;//utf8转gb2312function utf8ToGbk($str)&#123; return iconv("UTF-8","GB2312",$str);&#125;//mb_convert_encoding转编码function mbGbkToUtf8($str,$turn = 1)&#123; switch($turn)&#123; case 0: $newStr = mb_convert_encoding($str,"UTF-8","GB2312"); break; case 1: $newStr = mb_convert_encoding($str,"GB2312","UTF-8"); break; default: $newStr = '参数错误'; &#125; return $newStr;&#125; 判断一个数组是否全部为空12345678910$arr = [ ['a' =&gt; 1], [], [], ['b' =&gt; 2], [],];$felter = array_filter($arr);echo count($felter) === 0 ? '全部为空' : '部分为空'; 使用Carbon(laravel)计算两个时间相隔的年月日时分秒1234567891011121314151617181920212223242526272829303132333435363738/** * 使用Carbon(laravel)计算两个时间之差 * @param string $start 开始时间 * @param string $end 结束时间 * @param int $return 返回类型 * @return array|string */function carbon_time_diff($start, $end, $return = 1)&#123; $carbon = new Illuminate\Support\Carbon($start); $carbon = $carbon-&gt;diff(new Illuminate\Support\Carbon($end)); $years = $carbon-&gt;y; $months = $carbon-&gt;m; $days = $carbon-&gt;d; $hours = $carbon-&gt;h; $mins = $carbon-&gt;i; $seconds = $carbon-&gt;s; switch ($return) &#123; case 1: return $years . '年' . $months . '月' . $days . '天' . $hours . '小时' . $mins . '分钟' . $seconds . '秒'; break; case 2: $str = ''; !empty($years) &amp;&amp; $str .= $years . '年'; !empty($months) &amp;&amp; $str .= $months . '月'; !empty($days) &amp;&amp; $str .= $days . '天'; !empty($hours) &amp;&amp; $str .= $hours . '小时'; !empty($mins) &amp;&amp; $str .= $mins . '分钟'; !empty($seconds) &amp;&amp; $str .= $seconds . '秒'; return $str; break; default: return ['years' =&gt; $years, 'months' =&gt; $months, 'days' =&gt; $days, 'hours' =&gt; $hours, 'mins' =&gt; $mins, 'seconds' =&gt; $seconds]; break; &#125;&#125; 使用DateTime计算两个时间相隔的年月日时分秒1234567891011121314151617181920212223242526272829303132333435363738/** * 计算两个时间之差 * @param string $start 开始时间 * @param string $end 结束时间 * @param int $return 返回类型 * @return array|string * @throws Exception */function diff_date($start, $end, $return = 1)&#123; $datetime1 = new \DateTime($start); $datetime2 = new \DateTime($end); $interval = $datetime1-&gt;diff($datetime2); $years = $interval-&gt;format('%Y'); $months = $interval-&gt;format('%m'); $days = $interval-&gt;format('%d'); $hours = $interval-&gt;format('%H'); $mins = $interval-&gt;format('%i'); $seconds = $interval-&gt;format('%s'); switch ($return) &#123; case 1: return $years . '年' . $months . '月' . $days . '天' . $hours . '小时' . $mins . '分钟' . $seconds . '秒'; break; case 2: $str = ''; !empty($years) &amp;&amp; $years !== '00' &amp;&amp; $str .= $years . '年'; !empty($months) &amp;&amp; $months !== '00' &amp;&amp; $str .= $months . '月'; !empty($days) &amp;&amp; $days !== '00' &amp;&amp; $str .= $days . '天'; !empty($hours) &amp;&amp; $hours !== '00' &amp;&amp; $str .= $hours . '小时'; !empty($mins) &amp;&amp; $mins !== '00' &amp;&amp; $str .= $mins . '分钟'; !empty($seconds) &amp;&amp; $seconds !== '00' &amp;&amp; $str .= $seconds . '秒'; return $str; break; default: return ['years' =&gt; $years, 'months' =&gt; $months, 'days' =&gt; $days, 'hours' =&gt; $hours, 'mins' =&gt; $mins, 'seconds' =&gt; $seconds]; break; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珍藏多年的JS]]></title>
    <url>%2F2017%2F08%2F29%2F%E7%8F%8D%E8%97%8F%E5%A4%9A%E5%B9%B4%E7%9A%84js%2F</url>
    <content type="text"><![CDATA[这些都是工作中用到的比较常用或者有意思的js函数，持续更新中… 截取浏览器地址栏中的url方法一12345678910111213141516function getUrlVars()&#123; var vars = [], hash; var hashes = window.location.href.slice(window.location.href.indexOf('?')+1).split('&amp;'); for(var i = 0; i &lt; hashes.length; i++) &#123; hash = hashes[i].split('='); vars.push(hash[0]); vars[hash[0]] = hash[1]; &#125; return vars; &#125; var params = getUrlVars();var cateId = params[params[0]]; //0是第一个var cateId = parseInt(cateId); //字符串转数字var type = typeof(cateId); //查看数据类型console.log(cateId);console.log(type); 方法二123var str= window.location.href;var cateId = str.slice(-11); console.log(cateId); 方法三1234567function GetQueryString(name)&#123; var reg = new RegExp("(^|&amp;)"+ name +"=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null;&#125;var cateId= GetQueryString("cateId");console.log(cateId); 根据地址栏获取某个参数（post和get形式都可以）12345678910111213141516171819202122232425262728/** * TP分页时，获取地址栏中为以下两种形式的某个参数 * http://localhost/index.php/Personal/userInfo/type/ref/p/20.html * http://localhost/index.php/Personal/userInfo?type=refAll/p/2.html */$(function()&#123; function getUrlVars()&#123; var vars = [], hash; var hashes=window.location.href.slice(window.location.href.indexOf('?')+1).split('&amp;'); for(var i = 0; i &lt; hashes.length; i++) &#123; hash = hashes[i].split('='); vars.push(hash[0]); vars[hash[0]] = hash[1]; &#125; return vars; &#125; var broswerUrl = location.href; var re = broswerUrl.indexOf("?"); var type = ''; if(re == -1)&#123; //-1：未查询到 var arr = broswerUrl.split("/");//split:使用一个指定的分隔符把一个字符串分割存储到数组 type = arr[7];//查看数组得知，需要的字符串下标为7 &#125;else&#123; var params = getUrlVars(); type = params[params[0]]; &#125; console.log(type);&#125;); 时间戳转换成时间123456789101112131415161718/** * 将时间戳转换成时间：若不传参，获取当前时间戳 * @param times number 时间戳 * @returns &#123;string&#125; 年-月-日 时:分:秒 */function getdate(times) &#123; if(times)&#123; var time =Number(times +'000'); //将传入的时间戳增加3个0，变成微秒 var now = new Date(time); &#125;else&#123; var now = new Date(); &#125; var y,m,d; y = now.getFullYear(); m = now.getMonth() + 1; d = now.getDate(); return y + "-" + (m &lt; 10 ? "0" + m : m) + "-" + (d &lt; 10 ? "0" + d : d) + " " + now.toTimeString().substr(0, 8);&#125; jQuery生成二维码1：先引入jQuery插件文件1&lt;script type="text/JavaScript" src="../../public/js/jquery.qrcode.min.js"&gt;&lt;/script&gt; 2：生成可以保存的二维码图片和不可保存的二维码1234567891011$(function() &#123; var str = window.location.href; var payUrl = str.slice(-35); //获取微信支付的url //不生成二维码 $('#qrcode').qrcode(payUrl); $(".qrcodes").hide(); //生成二维码图片，可保存至本地 var qrcode= $('#qrcode').qrcode(payUrl).hide(); var canvas=qrcode.find('canvas').get(0); $('#imgOne').attr('src',canvas.toDataURL('image/jpg'))&#125;); 生成可保存至本地二维码图片的html1&lt;img id=&apos;imgOne&apos; src=&quot;&quot;&gt; 使用prompt和confirm进行简单的页面交互123456789101112function rec() &#123; var name = prompt("请输入姓名", ""); if(name != null)&#123; var sures = confirm('刚输入的姓名是：'+name); if(sures == true)&#123; alert('已记录'); &#125;else&#123; alert('您已取消，请重新输入'); &#125; &#125;&#125;rec(); 防止浏览器的返回上一页1234567891011121314//在不可返回的页面添加下面这段JS$(document).ready(function(e) &#123;var counter = 0;if (window.history &amp;&amp; window.history.pushState) &#123; $(window).on('popstate', function () &#123; window.history.pushState('forward', null, '#'); window.history.forward(1); alert("不可回退"); &#125;);&#125;window.history.pushState('forward', null, '#'); //在IE中必须得有这两行window.history.forward(1);&#125;); 获取验证码倒计时1&lt;input class="weui-btn weui-btn_warn" id="getVerify" type="button" value="获取验证码" onclick="sendCode(this)"&gt; 123456789101112131415161718192021222324252627282930313233343536373839function sendCode(thisBtn)&#123; var clock = ''; var nums = 60; var btn; var mobile = $("#tel").val(); if(mobile == '' || mobile.length != 11)&#123; weui.alert('请先输入正确的手机号'); &#125;else&#123; btn = thisBtn; btn.disabled = true; //将按钮置为不可点击 btn.value = '重新获取('+nums+')'; clock = setInterval(doLoop, 1000); //一秒执行一次 //调用接口 $.ajax(&#123; url:"/api/app/user/getVerifyCode", type:"post", dataType:"json", data:&#123;phone:mobile&#125;, success:function (data) &#123; if(data['status'] == 1)&#123; weui.toast(data['msg']); &#125;else&#123; weui.alert(data['msg']); &#125; &#125; &#125;); &#125; function doLoop()&#123; nums--; if(nums &gt; 0)&#123; btn.value = '重新获取('+nums+')' &#125;else&#123; clearInterval(clock); //清除js定时器 btn.disabled = false; btn.value = '获取验证码'; nums = 60; //重置时间 &#125; &#125; &#125; 图片上传12&lt;input id="upFile" class="weui-uploader__input" type="file" accept="image/*" multiple/&gt;&lt;img src="./src/images/pic_user_default.png" id="logo"&gt; 12345678910111213141516171819$("#upFile").on("change",function () &#123; var formData = new FormData(); formData.append("file",$("#upFile")[0].files[0]); $.ajax(&#123; url: "/api/app/uploadFile", type: "post", dataType: "json", contentType: false, // 注意这里应设为false processData: false, cache: false, data: formData, success: function (data) &#123; if(data["status"] == 1)&#123; var imgUrl = "http://106.14.148.77/api"+data["data"]; $("#logo").attr("src",imgUrl); &#125; &#125; &#125;)&#125;); js判断复选框是被选中1&lt;input type="checkbox" checked class="weui-agree__checkbox"&gt; 12var check = $('input[class="weui-agree__checkbox"]').is(':checked');alert(check == ture ? 'yes' : 'no'); js判断几个复选框被选中12345678&lt;input type="checkbox" value="1" class="test"&gt;11&lt;input type="checkbox" value="2" class="test"&gt;21&lt;input type="checkbox" value="3" class="test"&gt;31&lt;input type="checkbox" value="4" class="test"&gt;41&lt;input type="checkbox" value="5" class="test"&gt;51&lt;input type="checkbox" value="6" class="test"&gt;61&lt;input type="checkbox" value="7" class="test"&gt;71&lt;button id="btn"&gt;OK&lt;/button&gt; 123456789101112 $("#btn").click(function()&#123; var chk_value = []; $('input[class="test"]:checked').each(function() &#123; chk_value.push($(this).val()); &#125;); if(chk_value.length == 0)&#123; alert('你还没有选择任何内容！'); &#125;else&#123; alert(chk_value); &#125; // alert(chk_value.length == 0 ? '你还没有选择任何内容！': chk_value);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于JQuery网页漂浮广告窗口]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%9F%BA%E4%BA%8EJQuery%E7%BD%91%E9%A1%B5%E6%BC%82%E6%B5%AE%E5%B9%BF%E5%91%8A%E7%AA%97%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[首先说一下思路1.漂浮的窗口肯定是position:absolute脱离文档流的 2.在浏览器可视范围内飘动 3.飘动过程可分解为垂直（上、下）和水平（左、右）方向，同一时间内会同时向垂直和水平两个方向同时移动，可能的情况会有上左、上右、下左、下右 基本的思路是创建一个函数，函数的作用是使元素移动，然后定时执行这个函数，以让元素持续移动，形成漂浮效果。基本上这些持续的元素移动都是基于 setInterval(func,delay) 函数，例如：setInterval(move,30)，第一个参数是要定时执行的函数，第二个参数是时间间隔，单位是毫秒。如果不懂setInterval的请见：setInterval 介绍 首先这是基于JQuery写的，调用都是一些基础的接口，应该任何版本的JQuery都可以，我用的是1.9的。 效果图，箭头是大概的运行轨迹 代码浮窗Css样式12345&lt;style&gt; .floadAd &#123; position: absolute;z-index: 999900; display: none; &#125; .floadAd .item &#123; display: block; &#125; .floadAd .item img &#123; vertical-align: bottom; &#125;/* a img 的组合浏览器默认下边会有几个像素的空白，这里可以消除空白*/&lt;/style&gt; Html 标记，里面的内容是可以按自己的需要来写的 123456&lt;div id="floadAD" class="floadAd"&gt; &lt;a class="close" href="javascript:void();" style="color: red"&gt;×关闭&lt;/a&gt; &lt;a class="item" title='首届党建文化节' href="http://unsun.net" target="_blank"&gt; &lt;img src="App_UpLoad/image/20160405/20160405172215_2907.png" alt="首届党建文化节" /&gt; &lt;/a&gt;&lt;/div&gt; Js代码，我没有把它封装到JQuery的插件里面，有需要可以自己去封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354FloatAd("#floadAD");//调用//广告漂浮窗口function FloatAd(selector) &#123; var obj = $(selector); if (obj.find(".item").length == 0) return;//如果没有内容，不执行 var windowHeight = $(window).height();//浏览器高度 var windowWidth = $(window).width();//浏览器宽度 var dirX = -1.5;//每次水平漂浮方向及距离(单位：px)，正数向右，负数向左，如果越大的话就会看起来越不流畅，但在某些需求下你可能会需要这种效果 var dirY = -1;//每次垂直漂浮方向及距离(单位：px)，正数向下，负数向上，如果越大的话就会看起来越不流畅，但在某些需求下你可能会需要这种效果 var delay = 30;//定期执行的时间间隔，单位毫秒 obj.css(&#123; left: windowWidth / 2 - obj.width() / 2 + "px", top: windowHeight / 2 - obj.height() / 2 + "px" &#125;);//把元素设置成在页面中间 obj.show();//元素默认是隐藏的，避免上一句代码改变位置视觉突兀，改变位置后再显示出来 var handler = setInterval(move, delay);//定期执行，返回一个值，这个值可以用来取消定期执行 obj.hover(function() &#123;//鼠标经过时暂停，离开时继续 clearInterval(handler);//取消定期执行 &#125;, function() &#123; handler = setInterval(move, delay); &#125;); obj.find(".close").click(function() &#123;//绑定关闭按钮事件 close(); &#125;); $(window).resize(function() &#123;//当改变窗口大小时，重新获取浏览器大小，以保证不会过界（飘出浏览器可视范围）或漂的范围小于新的大小 windowHeight = $(window).height();//浏览器高度 windowWidth = $(window).width();//浏览器宽度 &#125;); function move() &#123;//定期执行的函数，使元素移动 var currentPos = obj.position();//获取当前位置，这是JQuery的函数，具体见：http://hemin.cn/jq/position.html var nextPosX = currentPos.left + dirX;//下一个水平位置 var nextPosY = currentPos.top + dirY;//下一个垂直位置 if (nextPosX &gt;= windowWidth - obj.width()) &#123;//这一段是本站特有的需求，当漂浮到右边时关闭漂浮窗口，如不需要可删除 close(); &#125; if (nextPosX &lt;= 0 || nextPosX &gt;= windowWidth - obj.width()) &#123;//如果达到左边，或者达到右边，则改变为相反方向 dirX = dirX * -1;//改变方向 nextPosX = currentPos.left + dirX;//为了不过界，重新获取下一个位置 &#125; if (nextPosY &lt;= 0 || nextPosY &gt;= windowHeight - obj.height() - 5) &#123;//如果达到上边，或者达到下边，则改变为相反方向。 dirY = dirY * -1;//改变方向 nextPosY = currentPos.top + dirY;//为了不过界，重新获取下一个位置 &#125; obj.css(&#123; left: nextPosX + "px", top: nextPosY + "px" &#125;);//移动到下一个位置 &#125; function close() &#123;//停止漂浮，并销毁漂浮窗口 clearInterval(handler); obj.remove(); &#125;&#125; 我已经把注释写的很清楚，这里就不再做多解释了，如果有有问题欢迎提出交流，一起进步。 第一次写博客，写的不好欢迎提出来让我改进 个人观点之前的博主把内容写得很清楚，我就不做多余的说明，我只想说一句：666。原文链接:基于JQuery网页漂浮广告窗口Js详解]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中常用操作命令]]></title>
    <url>%2F2017%2F07%2F31%2Flinux%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[整理一些常用的linux命令。 Linux简介及Ubuntu安装Linux，免费开源，多用户多任务系统。基于Linux有多个版本的衍生。RedHat、Ubuntu、Debian 安装VMware或VirtualBox虚拟机。具体安装步骤，找百度。 再安装Ubuntu。具体安装步骤，找百度。 安装完后，可以看到Linux系统的目录结构，见链接http://www.cnblogs.com/laov/p/3409875.html 常用指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent)cd 切换目录touch 创建空文件echo 创建带有内容的文件。cat 查看文件内容cp 拷贝mv 移动或重命名rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除find 在文件系统中搜索某文件wc 统计文本中行数、字数、字符数grep 在文本文件中查找某个字符串rmdir 删除空目录tree 树形结构显示目录，需要安装tree包pwd 显示当前目录ln 创建链接文件more、less 分页显示文本文件内容head、tail 显示文件头、尾内容ctrl+alt+F1 命令行全屏模式 系统管理命令12345678910111213141516171819202122232425262728293031stat 显示指定文件的详细信息，比ls更详细who 显示在线登陆用户whoami 显示当前操作用户hostname 显示主机名uname 显示系统信息top 动态显示当前耗费资源最多进程信息ps 显示瞬间进程状态 ps -auxdu 查看目录大小 du -h /home带有单位显示目录信息df 查看磁盘大小 df -h 带有单位显示磁盘信息ifconfig 查看网络情况ping 测试网络连通netstat 显示网络状态信息man 命令不会用了，找男人 如：man lsclear 清屏alias 对命令重命名 如：alias showmeit=&quot;ps -aux&quot; ，另外解除使用unaliax showmeitkill 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。 打包压缩相关命令1234567891011121314151617gzip：bzip2：tar: 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 例： tar -cvf /home/abc.tar /home/abc 只打包，不压缩 tar -zcvf /home/abc.tar.gz /home/abc 打包，并用gzip压缩 tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用bzip2压缩 当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。 关机/重启机器1234567891011shutdown -r 关机重启 -h 关机不重启 now 立刻关机halt 关机reboot 重启 Linux管道将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。 例：grep -r &quot;close&quot; /home/* | more 在home目录下所有文件中查找，包括close的文件，并分页输出。 Linux软件包管理dpkg (Debian Package)管理工具，软件包名以.deb后缀。这种方法适合系统不能联网的情况下。比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。 sudo dpkg -i tree_1.5.3-1_i386.deb 安装软件 sudo dpkg -r tree 卸载软件 注：将tree.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等； APT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。依然以tree为例 sudo apt-get install tree 安装tree sudo apt-get remove tree 卸载tree sudo apt-get update 更新软件 sudo apt-get upgrade 将.** rpm**文件转为.** deb** 文件 .rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。 sudo alien abc.rpm vim使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 命令模式下： 123456789101112131415:q 退出:q! 强制退出:wq 保存并退出:set number 显示行号:set nonumber 隐藏行号/apache 在文档中查找apache 按n跳到下一个，shift+n上一个yyp 复制光标所在行，并粘贴h(左移一个字符←)、j(下一行↓)、k(上一行↑)、l(右移一个字符→) 用户及用户组管理123456789101112131415161718192021222324252627282930313233/etc/passwd 存储用户账号/etc/group 存储组账号/etc/shadow 存储用户账号的密码/etc/gshadow 存储用户组账号的密码useradd 用户名userdel 用户名adduser 用户名groupadd 组名groupdel 组名passwd root 给root设置密码su rootsu - root /etc/profile 系统环境变量bash_profile 用户环境变量.bashrc 用户环境变量su user 切换用户，加载配置文件.bashrcsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 更改文件的用户及用户组sudo chown [-R] owner[:group] {File|Directory} 例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop 要想切换此文件所属的用户及组。可以使用命令。 sudo chown root:root jdk-7u21-linux-i586.tar.gz 文件权限管理三种基本权限123456R 读 数值表示为4W 写 数值表示为2X 可执行 数值表示为1 如图所示，jdk-7u21-linux-i586.tar.gz文件的权限为-rw-rw-r-- -rw-rw-r--一共十个字符，分成四段。 第一个字符“-”表示普通文件；这个位置还可能会出现“l”链接；“d”表示目录 第二三四个字符“rw-”表示当前所属用户的权限。 所以用数值表示为4+2=6 第五六七个字符“rw-”表示当前所属组的权限。 所以用数值表示为4+2=6 第八九十个字符“r–”表示其他用户权限。 所以用数值表示为2 所以操作此文件的权限用数值表示为662 更改权限sudo chmod [u所属用户 g所属组 o其他用户 a所有用户] [+增加权限 -减少权限] [r w x] 目录名 例如：有一个文件filename，权限为“-rw-r----x” ,将权限值改为&quot;-rwxrw-r-x&quot;，用数值表示为765 sudo chmod u+x g+w o+r filename 上面的例子可以用数值表示 sudo chmod 765 filename 原文大牛笔记]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStorm配置Xdebug]]></title>
    <url>%2F2017%2F06%2F21%2FPHPStorm%E9%85%8D%E7%BD%AEXdebug%2F</url>
    <content type="text"><![CDATA[配置分为两部分，一是Xdebug的下载和安装，二是PHPStorm上的对Xdebug的配置。 Xdebug下载下载Xdebug查看phpinfo，搞清楚php版本等信息： 根据PHP版本下载合适版本的Xdebug 配置php.ini在php.ini的最后加入下面这些代码。 zend_extension的路径是Xdebug文件的目录。 123456789[Xdebug]zend_extension = C:\xampp\php\ext\php_xdebug-2.5.4-5.6-vc11.dllxdebug.remote_enable = 1xdebug.remote_host = localhostxdebug.remote_port = 9000xdebug.remote_handler = dbgpxdebug.remote_autostart = 1xdebug.idekey = PHPSTORM 重启apache查看是否配置成功phpinfo() PHPstorm上 PHPstorm配置已下配置信息是根据我本地的配置，而做的配置，请勿直接复制。 如上图：这里配置端口（9000）的需要和在php.ini中的配置要一致，不一定非要用9000端口，只要是一个未被占用的端口都行。 如上图： phpstorm中的IDE key需要和在php.ini中的配置要一致，只要两者配置一样都可以，不需要非要写成PHPSTORM； Host和Port是要调试的本地虚拟域名配置项。 参考PHPstorm官方文档 Xdebug安装指南 验证您的调试配置 使用Xdebug和PhpStorm进行零配置Web应用程序调试 其他 phpstorm配置Xdebug进行调试PHP教程 本地环境phpStorm10+XDebug配置和断点调试]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>PHPStorm</tag>
        <tag>Xdebug</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP版本中的VC6,VC9,VC11,TS,NTS区别]]></title>
    <url>%2F2017%2F06%2F21%2FPHP%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84VC6%2CVC9%2CVC11%2CTS%2CNTS%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[VC6：legacy Visual Studio 6 compiler，就是使用这个编译器编译的VC9：Visual Studio 2008 compiler，就是用微软的VS编辑器编译的TS：Thread Safe 线程安全， 执行时会进行线程（Thread）安全检查NTS：Non Thread Safe 非线程安全， 在执行时不进行线程（Thread）安全检查 以windows为例，看看下载到得php zip的文件名 php-5.4.4-nts-Win32-VC9-x86.zip VC6：legacy Visual Studio 6 compiler，就是使用这个编译器编译的。 VC9：Visual Studio 2008 compiler，就是用微软的VS编辑器编译的。 这个其实没有什么太大的影响，因为从php 5.3，已经没有vc6版本提供下载了 TS：Thread Safe线程安全， 执行时会进行线程（Thread）安全检查 NTS：Non Thread Safe 非线程安全， 在执行时不进行线程（Thread）安全检查 我使用Apache+PHP的模式下，一般是把PHP作为一个Module load到apache中，那么以apache父进程-多子进程的工作模式，是需要进行线程安全检查的，所以如果是以这种方式执行php，选择ts版本 那么如果是使用fastcgi，比如说用php-fpm管理php执行，则不需要进行线程安全检查，则选择nts版本的php php 5.5.0 beta 1发布后, 安装出现问题, 家中电脑升级是成功的, 可公司的电脑一直提示无法加载到服务. 操作系统都一样的, 没什么区别www.php.net官网左侧的说明提醒了我. php-5.5.0beta1-Win32-VC11-x86 安装包的名字也已经说明了, 要运行必须安装vc11, x86表示32位, 假如是x64就是64位, 位数对于安装vc11有帮助, 个人建议vc11 x86, x64两个版本都安装上比较好, 反正没冲突. 然后启动服务, 搞定phpinfo信息如下: VC6：legacy Visual Studio 6 compiler，就是使用这个编译器编译的。 VC9：Visual Studio 2008 compiler，就是用微软的VS编辑器编译的。 由于apache.org只提供VC6的版本，所以使用原版apache时只能使用VC6。（www.apachelounge.com上有apache VC9的版本提供，应该可以和PHP VC9配合，没用过） TS：Thread Safe 线程安全， 执行时会进行线程（Thread）安全检查，以防止有新要求就启动新线程的CGI执行方式而耗尽系统资源 NTS：Non Thread Safe 非线程安全， 在执行时不进行线程（Thread）安全检查 PHP的两种执行方式：ISAPI和FastCGI。 ISAPI`(Internet Server Application Programming Interface)执行方式是以DLL动态库的形式使用，可以在被用户请求后执行，在处理完一个用户请求后不会马上消失，所以需要进行线程安全检查，这样来提高程序的执行效率，所以如果是以ISAPI来执行PHP，建议选择hread Safe`版本 apache中的配置方式： 下面这个是加载TS版本的php必须的 LoadModule php5_module “xxx/php5apache2_2.dll” 下面这行可有可无 AddType application/x-httpd-php-source .phpsAddType application/x-httpd-php .php .php5 .php4 .php3 .phtml .phpt FastCGI执行方式是以单一线程来执行操作，所以不需要进行线程的安全检查，除去线程安全检查的防护反而可以提高执行效率，所以，如果是以FastCGI来执行PHP，建议选择Non Thread Safe版本。 apache中的配置方式： 下面这两行是加载NTS版本的php必须的，不可以直接写成Action application/x-httpd-php “c:/wamp/bin/php/php3.5.6/php-cgi.exe”！ 12ScriptAlias /php/ "C:/wamp/bin/php/php3.5.6/"Action application/x-httpd-php “/php/php-cgi.exe” 另外，还要有之前的AddType application/x-httpd-php .php .php5 .php4 .php3 .phtml .phpt，这样才能认识php格式的文件 这样配置完可能还会因为权限问题而无法用php-cgi.exe解析php网页，所以还要加上下面这段 123456&lt;Directory "C:/wamp/bin/php/php5.3.6/"&gt;AllowOverride NoneOptions NoneOrder allow,denyAllow from all&lt;/Directory&gt; 官方并不建议你将Non Thread Safe应用于生产环境，所以我们选择Thread Safe版本的PHP来使用。 XAMPP在http-xampp.conf中默认配置是使用ISAPI的方式 原文：PHP版本中的VC6,VC9,VC11,TS,NTS区别]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型:char与varchar类型的区别]]></title>
    <url>%2F2017%2F06%2F16%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-char%E4%B8%8Evarchar%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在建立数据库表结构的时候，为了给一个String类型的数据定义一个数据库的数据库类型，一般参考的都是char或者varchar，这两种选择有时候让人很纠结，今天想总结一下它们两者的区别，明确一下选择它们的理由。 首先明确的是，char的长度是不可变的，而varchar的长度是可变的，也就是说，定义一个char[10]和varchar[10],如果存进去的是csdn,那么char所占的长度依然为10，除了字符csdn外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的，尽管如此，char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找； 但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。 再者，char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。 原文链接: 数据库中char与varchar类型的区别]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP用PHPExcle导出Excel文件]]></title>
    <url>%2F2017%2F06%2F10%2FThinkPHP%E7%94%A8PHPExcle%E5%AF%BC%E5%87%BAExcel%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本篇博客主要讲述，如何在thinkPHP中使用PHPExcel中导出Excel文件，是博主在实践了好多篇别人的帖子之后，总结归纳出来的文章，亲测可用。 准备工作下载、配置PHPExcel扩展插件 去PHPExcel的官网或者github去下载最新PHPExcel放到ThinkPHP/Library/Vendor目录下，Vendor目录是放置PHP扩展包的默认文件夹，在Vendor目录下建立PHPExcel文件夹，将下载的文件，解压到此处。 将PHPExcel.php文件，重命名成PHPExcel.class.php。 至此，插件安装已经做好，目录结构如下图，接下来做功能部分。 创建Excel方法生成Excel文件方法1234567891011121314151617181920212223242526272829303132333435363738/** * 数据导出为.xls格式 * @param string $fileName 导出的文件名 * @param $expCellName array -&gt; 数据库字段以及字段的注释 * @param $expTableData Model -&gt; 连接的数据库 */ public function exportExcel($fileName='table',$expCellName,$expTableData)&#123; $xlsTitle = iconv('utf-8', 'gb2312', $fileName);//文件名称 $xlsName = $fileName.date("_Y.m.d_H.i.s"); //or $xlsTitle 文件名称可根据自己情况设定 $cellNum = count($expCellName); $dataNum = count($expTableData); import("Vendor.PHPExcel.PHPExcel"); import("Vendor.PHPExcel.Writer.Excel5"); import("Vendor.PHPExcel.IOFactory.php"); $objPHPExcel = new \PHPExcel(); $cellName = array('A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','AA','AB','AC','AD','AE','AF','AG','AH','AI','AJ','AK','AL','AM','AN','AO','AP','AQ','AR','AS','AT','AU','AV','AW','AX','AY','AZ'); $objPHPExcel-&gt;getActiveSheet(0)-&gt;mergeCells('A1:'.$cellName[$cellNum-1].'1');//合并单元格 $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue('A1', $fileName.' Export time:'.date('Y-m-d H:i:s')); for($i=0;$i&lt;$cellNum;$i++)&#123; $objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue($cellName[$i].'2', $expCellName[$i][1]); &#125; // Miscellaneous glyphs, UTF-8 for($i=0;$i&lt;$dataNum;$i++)&#123; for($j=0;$j&lt;$cellNum;$j++)&#123; $objPHPExcel-&gt;getActiveSheet(0)-&gt;setCellValue($cellName[$j].($i+3), $expTableData[$i][$expCellName[$j][0]]); &#125; &#125; header('pragma:public'); header('Content-type:application/vnd.ms-excel;charset=utf-8;name="'.$xlsTitle.'.xls"'); header("Content-Disposition:attachment;filename=$xlsName.xls");//attachment新窗口打印inline本窗口打印 $objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5'); $objWriter-&gt;save('php://output'); exit; &#125; 方法生成说明 第9行的 $xlsName = $fileName.date(&quot;_Y.m.d_H.i.s&quot;); //or $xlsTitle 文件名称可根据自己情况设定 是设置文件名，上面所写是文件名_Y.m.d_H.i.s，_Y.m.d_H.i.s即是导出的时间，因为windows下，文件名中不能含有:，所以即便写成_Y.m.d_H:i:s，导出的文件也是_Y.m.d_H.i.s这种样式。 第13行~15行的 123import("Vendor.PHPExcel.PHPExcel");import("Vendor.PHPExcel.Writer.Excel5");import("Vendor.PHPExcel.IOFactory.php"); 这三行即是引入PHPExcel，因为当时的文件目录结构是ThinkPHP/Library/Vendor/PHPExcel，所以import(&quot;Vendor.PHPExcel.PHPExcel&quot;);，注意目录结构，只要引入的位置和放置PHPExcel的目录相同即可； 第20、21行的 12$objPHPExcel-&gt;getActiveSheet(0)-&gt;mergeCells('A1:'.$cellName[$cellNum-1].'1');//合并单元格$objPHPExcel-&gt;setActiveSheetIndex(0)-&gt;setCellValue('A1', $fileName.' Export time:'.date('Y-m-d H:i:s')); 此作用是，在Excel文件的第一行合并一行单元格，用作表格的标题或简介。如下图所示： setCellValue(&#39;A1&#39;, $fileName.&#39; Export time:&#39;.date(&#39;Y-m-d H:i:s&#39;));值可以根据自己需求修改; 第34行的header(&quot;Content-Disposition:attachment;filename=$xlsName.xls&quot;);//attachment新窗口打印inline本窗口打印 可以设置输出的文件格式，此处写的是.xls，可修改成.xlsx。 此方法调用时需要传入三个参数（在方法开头的注释中已经说了），这里再具体说明一下： 123$fileName 导出的文件的文件名$expCellName 数据库字段以及字段的注释（数组） $expTableData 连接的数据库 方法调用调用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344/**导出**/ public function msgOut()&#123; $excel = A('Excel'); $xlsCell = array( array('id', 'ID'), array('staff_name', '昵称'), array('staff_real', '真实姓名'), array('mobile', '手机号'), array('card_id', '身份证号'), array('referee', '推荐人'), array('game_id', '游戏ID'), array('money', '余额'), array('consume_coin', '消费币'), array('create_time', '注册时间'), array('status', '状态'), ); $xlsName = 'Staff表搜索结果导出'; $field = null; foreach ($xlsCell as $key =&gt; $value) &#123; if($key == 0)&#123; $field = $value[0]; &#125;else&#123; $field .= "," . $value[0]; &#125; &#125; $xlsModel = M('Staff'); if (IS_POST) &#123; $map = $this -&gt; _queryTime(); $staff_name = I('staff_name'); if($staff_name) &#123; if (is_numeric($staff_name)) &#123; $map["id|staff_name"] = array(intval($staff_name), array('like', '%' . $staff_name . '%'), '_multi' =&gt; true); &#125; else &#123; $map['staff_name'] = array('like', '%' . (string)$staff_name . '%'); &#125; &#125; $xlsData = $xlsModel-&gt;Field($field)-&gt;where($map)-&gt;order('id DESC')-&gt;select(); &#125; foreach ($xlsData as $k =&gt; $v) &#123; $xlsData[$k]['create_time'] = $v['create_time'] == null ? '-' : date("Y-m-d H:i",$v['create_time']); $xlsData[$k]['status'] = $v['status'] == 1 ? '正常' : '禁用'; &#125; $excel-&gt;exportExcel($xlsName,$xlsCell,$xlsData); &#125; 调用说明 第3行$excel = A(&#39;Excel&#39;);这个方法我写在了Application/Admin/Controller/ExcelController.class.php中，当前用的控制器是MainController.class.php，调用其他控制器中的方法，用TP中自带的A()，所以第51行，用的是$excel-&gt;exportExcel($xlsName,$xlsCell,$xlsData);，如果你的exportExcel()方法和当前调用的方法在同一个控制器内，那么第三行可以不写，第51行改成$this-&gt;exportExcel($xlsName,$xlsCell,$xlsData);。 第4行$xlsCell是导出这张表中所有的字段，以及字段的注释，导出后，不能把字段作为表格的列名，不知道数据库字段是什么意思的用户，看了这张表也不知所以然。 第17~24行是根据$xlsCell数组中，提取出来字段名，作为一个字符串，在查询时使用。当然也可以把这个字段名的字符串手写出来，我这里用的是foreach处理。 第27~38行是查询条件和查询结果，如果没有查询条件，想把整张表导出的话，直接用$xlsData = $xlsModel-&gt;Field($field)-&gt;order(&#39;id DESC&#39;)-&gt;select();即可。 第47~50行是对$xlsData结果进行处理，我写的两个意思是：1、当create_time字段为空的时候，值为 - ，有值的时候，就用date()函数把时间戳处理成日期；2、当status字段的值为1的时候，显示为正常,当值为0的时候禁用。 有点罗嗦了，见谅。 模板文件模板文件很简单，就一个提交。 12345678910&lt;form action="&#123;:U('Main/msgOut')&#125;" method="post" class="form-horizontal"&gt; &lt;div class="search-form fr cf"&gt; &lt;div class="sleft"&gt; &lt;input type="text" class="search-input" onClick="WdatePicker()" name="start_time" style="cursor: pointer;" value="&#123;:I('start_time')&#125;" id="start" placeholder="开始日期" /&gt; &lt;input type="text" class="search-input" onClick="WdatePicker()" name="end_time" style="cursor: pointer;" value="&#123;:I('end_time')&#125;" id="end" placeholder="结束日期" /&gt; &lt;input type="text" name="staff_name" class="search-input" value="&#123;:I('staff_name')&#125;" id="name" placeholder="输入推广专员的昵称或者ID"&gt; &lt;button type="submit" class="btn" id="out"&gt;导出&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; form表单中三个input，是搜索条件，如果没有的话，直接写button即可。 文章结束，欢迎转载。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>ThinkPHP</tag>
        <tag>PHP</tag>
        <tag>PHPExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wannacry病毒是纸老虎，没什么技术含量炒作过多]]></title>
    <url>%2F2017%2F05%2F18%2Fwannacry%E7%97%85%E6%AF%92%EF%BC%8C%E6%98%AF%E7%BA%B8%E8%80%81%E8%99%8E%EF%BC%8C%E6%B2%A1%E4%BB%80%E4%B9%88%E6%8A%80%E6%9C%AF%E5%90%AB%E9%87%8F%E7%82%92%E4%BD%9C%E8%BF%87%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[最近wannacry病毒席卷全球，也让其成为了媒体焦点，而国内的各个杀毒软件公司也趁机出动，帮助用户拦截病毒，确实做了很多好事。 虽然是好事，但我依然认为最近一轮的PR做的有点多，甚至拉动了整个杀毒概念股，这多少有点误导，所以这篇文章从产业和技术的角度再来谈谈wannacry病毒这件事。 1根据最新消息，比特币检测机构的数据显示wannacry的制作者们目前获得了7万美元的赎金。 而造成如此全球大规模的破坏，最终只获得了7万美元的赎金，黑客们还要像淘宝客服一样一个个发货，清点仓库，不断研究新病毒，想想也真不容易。 简单的说，造成如此大规模破坏，与其最后的收益多少是不成正比的 ，就这点赎金，真的还不如卖上几个G的大公司数据库赚钱。 这种规模不经济背后，反应的是PC到移动的产业链变革，以及技术的变迁。 2先聊聊过去的黑客产业，确实非常发达。 以前的黑客都喜欢建立长期价值，更多都是在制作木马病毒，并实现对用户电脑的控制，业内简称“抓肉鸡”，这样就可以通过各种黑产来变现，我这里举3个关键产业。 CPA赚钱：即给各路软件，金山毒霸、360、9158等等进行每台机器的安装，每安装一台就会分成0.5-3元。 CPC赚钱：一般都是在利用肉鸡制造虚假的广告流量点击，或者用于服务器攻击，搜索引擎关键词欺骗，恶意点击对手关键词等等，总之都是在做违法流量。 盗号赚钱：比如说，淘宝上最早的半价QQ会员、黄钻、红钻、蓝钻、QB这些，都是黑客通过入侵宽带账号，对其进行的宽带费盗刷的结果。 当然，最赚钱的还是游戏账号，通过安装各类游戏密码，截获各游戏账号，当年比较火热的传奇、梦幻西游、仙剑、DNF等等。黑客一般都是先改密码再转移装备，在游戏中与其他玩家交易成金币后，然后放到淘宝上卖金币，最后还会再观察这个账号是否还会被找回，如果不被找回，那么就会也拿出来卖。 可以说，以前的PC时代，有着非常多的黑产变现手法，通过控制一台电脑，就能获得相当多的收益。 蠕虫病毒都是一波流，媒体一曝光全都见光死，漏洞补上就没机会了，高手黑客都是做木马病毒，控制电脑建立长期价值。 现在的黑客开始对PC电脑进行一波流的收割，是因为PC的商业时代过去了，都集中在移动手机了。 3既然智能手机的产业那么大，那黑客为什么不入侵安卓，IOS？ 这里我再从技术角度谈谈为什么智能手机大规模入侵为什么那么少。 因为权限问题。 PC电脑需要应对用户无数需求，编程需求、图像处理需求、显卡更换需求、内存更换需求……. 这些无数种乱七八糟的需求，导致了微软不得不做成极度开放的系统，让用户可以自由操控底层权限，自由拔插各种软硬件，这也导致了黑客更容易找到漏洞。 找到不是问题，问题是，一次入侵后就可以实现全面的掌控，比如你在国内安装一个软件，往往安装的都是全家桶，你随便点击一个“确定”，一堆软件就到桌面上了，任何软件都有能力操控底层代码，这是由于过分开放导致的必然结果。 智能手机的权限就比较严格。 安卓和苹果本质上都差不多，给软件的权限都非常严格，比如你要读取个通讯录是需要用户允许的，你要连接个wifi是需要用户允许的，你要后台跑流量还是需要用户允许的……. 这样就导致了杀毒软件只能在既定的范围内行事，能做的事情比较少，之前360由于越界还被苹果下架过，UBER也做出过出格行为被苹果约谈，可以看出苹果的监控有多严格。 这就保证了真正的底层权限都甚至不会被用户掌握，也自然不会下放给其他软件，你安装一个软件，也不会出现安装全家桶的现象。 对于智能手机而言，用户没事不会去换主板、换CPU、换各种设备，也不会用手机编程，需要底层环境变量配置，需要取得各种底层权限，因此智能手机的权限可以对用户实行全面封闭，即使root权限，也依然受到严格限制。 而这种权限设计，也导致了没有那么多的漏洞需要补，黑客入侵也非常困难。 4当然，没有不能攻破的系统，智能手机的权限再严格，只要有利益在，还是挡不住黑客的。 智能手机稍有入侵，还有个原因在于，黑产也受到了智能手机的冲击，很多黑产给断了。 比如CPC、CPA这种广告联盟变现逻辑，就很难通过强行静默安装的方式实现，因为没有权限。 而盗号产业，现在大家都是用手机注册各种账号，黑客必须实现短信拦截，这就导致了需要建伪基站，或者入侵用户的线上短信接收平台，等等，成本极高，机会也少。 当然，这么做最终依然无法实现盗号，因为账号都与手机绑定，一个验证码就能找回，根本不能永久拿下。 所以智能手机的黑产集中在了盗刷层面，之前网易邮箱账号泄露，就有大批的Appstore的账号被盗刷，被用于购买了各种游戏装备，但是只要用户通过合理的申诉，还是能够通过苹果找回，黑客弄了半天，其实很容易竹篮打水一场空。 另外，苹果手机此前也出现过勒索局面，黑客通过获得苹果账号，设置icloud丢失锁定手机，来要求用户赎回苹果账号。当然这和入侵无关，是低级的暴库行为，主要是下游产业链完成，没技术含量的。 所以，智能手机除了封锁权限，还把黑产财路也截断了很大一部分。 5PC和智能手机两边都在截断黑产收入，在这两边的收入锐减情况下，此次CY病毒选择了一波收割。 但我依然认为CY只是纸老虎，一波收割的蠕虫病毒，不是建立对电脑的暗中长期控制，没什么吓人的。 公司或者机构电脑上可能会有值钱的资料，但是普通个人用户有多少值钱的资料？我认为绝大多数的人资料基本不会超 过300美元，## 如果绝大多数人的电脑资料超过300美元，那么此次黑客们都要赚翻了。## 举个 例子，比如说论文这种东西吧，300美元这么贵，在国内完全都可以找人代写了代发了，重写就行了，绝大多数人不会交这个赎金。 另外，现在都是云端时代，很多人都已经把资料放到云端，是云端实时备份的，电脑中毒对于这些已经备份云端的人群来说，一点都不重要。 再说学校机、加油站、出入境管理处的电脑中毒，我认为也不是什么大事，所有资料都在服务器里面，黑客入侵的不是后端服务器，一个前端电脑坏了重装就行了，用户的信息没丢就根本不是什么大事。 大惊小怪的往往是外行。 6说了这么多，既然手机的病毒木马都没啥怕的，都是纸老虎，那么真老虎是啥？ 真老虎是服务器入侵。 TOC越来越难以收割，因此这波黑产已经全面进入到TOB阶段，靠入侵各个公司，盗取数据库资料，这是远比非标准化的个人PC和智能收机入侵更赚钱的事情。 比如之前icloud的明星艳照，就非常值钱，刚开始能卖好多钱。再比如之前泄露的网易邮箱数据库、雅虎数据库、优酷数据库，58简历数据库等等，都是非常值钱的。 尤其是邮箱数据库，很多黑客可以通过邮箱数据库去盗刷各个游戏账号，锁定用户的icloud勒索，自己用完后最后再倒卖几波，虽然产业链下游的人辛苦点，但整个产业还是能赚很多。 不过以上依然不算是太严重的破坏。 各位想想，这次入侵只不过是在逼你删掉一些本来就没用的文件，但是如果这次攻击的不是PC电脑，而是服务器，黑客把各个国家公民的数据锁了（甚至连同各地备份服务器数据一起锁住），把你的房产信息锁了，那该有多可怕？ 不过幸运的是，这次依然是低级入侵，其只不过是在利用微软3月份就已经打过补丁的漏洞在做事，高级的入侵是直接入侵服务器，大面积的入侵全球服务器的漏洞，这才是能够令人恐慌的。 7所以我认为，未来值得警惕的是服务器安全。 但是这和360这些杀毒公司半毛钱都没有，因为现在都是云服务器，是AWS和阿里云的天下，要做好安全把控的是这些云服务商。 但对于这些云服务商来说，他们做的其实非常不错，一旦发现漏洞，就会立即全网打补丁，这种中心化的控制，不会错过一台电脑。相比于混乱的个人电脑，这种中心化的管理，更能够防御黑客的漏洞入侵。 所以云服务器的安全才是未来整个安全行业的焦点，这次如果要是aws和阿里云如果被入侵了，事情的严重程度就比较高了。 这次杀毒概念股疯长，我认为需要冷静，未来的安全攻防战一定是服务器端的，而不是用户端，杀毒软件依然是用户端产品。 8黑客 可以制造出这么严重的全球性破坏，却只收获了几万美元，还要充当客服角色，反映的是当前的黑产的整体萧条状况。 不过无论怎么样，杀毒软件们做的事情是对的，但是这种短期PR有些过头，个人安全并不是未来的发展方向，服务器安全才是，而杀毒软件要想获得全新的增长，则必须找到自己全新的增量。 而作为个人，将自己的资料同步到云端，其实比安装一个杀毒软件更重要。 作者微信公众号：“首席发言者” 原文链接]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>互联网安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令图解]]></title>
    <url>%2F2017%2F05%2F05%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Git 是一款非常优秀的版本控制工具，但是苦于Git晦涩难懂的man pages，还有众多的命令选项和怪异的用法，Git有点难学。 这篇文章分享我学习过程中收藏的一些好图，并围绕这些图讲讲我对Git的理解，希望对大家有所帮助。 Git 工作流程了解Git，首先要弄清楚对象在被Git管理过程中所处的4个阶段，分别是： 1）工作目录 2）index(又称为暂存区) 3）本地仓库 4）远程仓库 管理过程图如下： 从时间先后来讲，工作目录的内容是你当前看到的，也是最新的； index区标记了你当前工作目录中，哪些内容是被git管理的； 而本地仓库保存了对象被提交过的各个版本，比起工作目录和暂存区的内容，它要更旧一些； 远程仓库是本地仓库的异地备份，远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步， 但是它的内容是最旧的 。 任何对象都是在工作目录中诞生和被修改；任何修改都是从进入index区才开始被版本控制；只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；而要与协作者分享本地的修改，可以把它们push到远程仓库来共享。 图最上方的add、commit、push等，展示了git仓库的产生过程。反过来，我们可以从远程历史仓库中获得本地仓库的最后一个版本，clone到本地，从本地检出对象的各个版本到index暂存区或工作目录中，从而实现任何对象或整个仓库的任意阶段状态的”回滚”。当正向和反向都能自由切换后，git就强大到无所不能了。 一开始接触这些概念可能比较绕，其实在git入门阶段，可以先抛开远程仓库不看，只了解管理本地仓库的”3棵树”就够了。 如下图： Git常用命令在开始之前，我们需要把下面的图看懂： 上图说明： HEAD，头，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 working directory，它是你的工作目录，也是当前你看到的东西。你的工作目录是与版本、分支相关的。 stage的东西虽然看不见，但是执行git status就会看到哪些对象的修改将在下一次commit的时候被放进本地仓库。这些东西称为stage。 commitcommit把暂存区的内容存入到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 如果对最后一次commit不满意，可以使用 git commit --amend来进行撤销，修改之后再提交。 如图所示的，ed489被4ca87取代，但是git log里看不到ed489的影子，这也正是amend的本意：原地修改，让上一次提交不露痕迹。 checkoutcheckout用来检出并切换分支。checkout成功后，HEAD会指向被检出分支的最后一次提交点。 对应的，工作目录、暂存区也都会与当前的分支进行匹配。下图是执行 git checkout maint后的结果： resetreset命令把当前分支指向另一个位置，并且相应的变动工作目录和索引。 如下图，执行 git reset HEAD~3后，当前分支相当于回滚了3个提交点，由ed489回到了b325c： reset有3种常用的模式： –soft，只改变提交点，暂存区和工作目录的内容都不改变–mixed，改变提交点，同时改变暂存区的内容。这是默认的回滚方式–hard，暂存区、工作目录的内容都会被修改到与提交点完全一致的状态 diff在commit、merge、rebase、打patch之前，通常都需要看看这次提交都干了些什么，于是diff命令就派上用场了： 来比较下上图中5种不同的diff方式： 比较不同的提交点之间的异同，用 git diff 提交点1 提交点2 比较当前分支与其他分支的异同，用 git diff 其他分支名称 在当前分支内部进行比较，比较最新提交点与当前工作目录，用 git diff HEAD 在当前分支内部进行比较，比较最新提交点与暂存区的内容，用 git diff --cached 在当前分支内部进行比较，比较暂存区与当前工作目录，用 git diff看起来有点复杂？是的，记不住的时候就看看这些图吧。 mergemerge命令把不同的分支合并起来。 如下图，HEAD处于master分支的ed489提交点上，other分支处于33104提交点上，项目负责人看了下觉得other分支的代码写的不错，于是想把代码合并到master分支，因此直接执行 git merge other，如果没有发生冲突，other就成功合并到master分支了。 rebaserebase又称为衍合，是合并的另外一种选择。 merge把两个分支合并到一起进行提交，无论从它们公共的父节点开始(如上图，other分支与master分支公共的父节点b325c)，被合并的分支(other分支)发生过多少次提交，合并都只会在当前的分支上产生一次提交日志，如上图的f8bc5。所以merge产生的提交日志不是线性的，万一某天需要回滚，就只能把merge整体回滚。而rebase可以理解为verbosely merge，完全重演下图分支topic的演化过程到master分支上。如下图： 在开始阶段，我们处于topic分支上，执行 git rebase master，那么169a6和2c33a上发生的事情都在master分支上重演一遍，分别对应于master分支上的e57cf和f7e63，最后checkout切换回到topic分支。 这一点与merge是一样的，合并前后所处的分支并没有改变。 git rebase master，通俗的解释就是topic分支想站在master的肩膀上继续下去。 cherry-pickcherry-pick命令复制一个提交点所做的工作，把它完整的应用到当前分支的某个提交点上。 rebase可以认为是自动化的线性的cherry-pick。 例如执行 git cherry-pick 2c33a: 正反过程对比理解了上面最晦涩的几个命令，我们来从正反两个方向对比下版本在本地的3个阶段之间是如何转化的。 如下图(history就是本地仓库)： 如果觉得从本地工作目录到本地历史库每次都要经过index暂存区过渡不方便，可以采用图形右边的方式，把两步合并为一步。 Some Tips如何管理空文件夹git本身不会对空文件夹进行版本控制，如果希望项目被clone后自带一些空目录，那么可以： 用git实现远程备份在要被管理的空目录下创建.gitignore文件。 在.gitignore文件内写入如下代码。第一行忽略所有文件。第二行除了.gitignore文件不被忽略。*!.gitignore git本地仓库的初始化采用 git init .即可。如果需要搭建异地备份，除了可以使用开源的gitlab等来搭建服务器外，还可以 git --bare init .来初始化远服务器仓库，然后把本地仓库推送到服务器仓库。这样可以轻松实现代码或文档的异地备份，即使把代码备份到本地也是可以的(这或许可以避免rm -rf *的悲剧哦)： git remote add origin git://127.0.0.1/abc.git然后建立本地到本地的ssh信任关系，enjoy yourself！ 无密码登陆git服务器调试技巧：ssh -v git@github.com GIT与知识管理日常工作中，我习惯用git来管理github和本地的代码；也用git来管理各种配置文件，例如.vimrc，.bashrc等，以及各种技术文档。 感谢Linux大神为我们写了这么好的工具！ 摘自米扑博客]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D方法与M方法的区别_ThinkPHP]]></title>
    <url>%2F2017%2F05%2F02%2FD%E6%96%B9%E6%B3%95%E4%B8%8EM%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB-ThinkPHP%2F</url>
    <content type="text"><![CDATA[在ThinkPHP中，可以无需进行任何模型定义。只有在需要封装单独的业务逻辑的时候，模型类才是必须被定义的。 D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复实例化。 D方法实例化模型类的时候通常是实例化某个具体的模型类，如果仅仅是对数据表进行基本的CURD操作的话，使用M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。 D方法实例化D方法的参数就是模型的名称，并且和模型类的大小写定义是一致的，例如： 参数 描述 模型名 模型的名称::和数据表前缀一起配合用于自动识别数据表名称 数据表前缀 当前数据表前缀::和模型名一起配合用于自动识别数据表名称 数据库连接信息 当前数据表的数据库连接信息::如果没有则获取配置文件中的 如果在Linux环境下面，一定要注意D方法实例化的时候的模型名称的大小写。 D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复实例化。 12345D方法还可以支持跨模块调用，需要使用：//实例化Admin模块的User模型D('Admin/User');//实例化Extend扩展命名空间下的Info模型D('Extend://Editor/Info'); D方法实例化模型类的时候通常是实例化某个具体的模型类。 D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复实例化。 注意：跨模块实例化模型类的时候 不支持自动加载公共模块的模型类。 M方法实例化模型M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。 M方法也可以支持跨库操作，例如： 12345// 使用M方法实例化 操作db_name数据库的ot_user表$User = M('db_name.User','ot_');// 执行其他的数据操作$User-&gt;select(); M方法的参数和\Think\Model类的参数是一样的，也就是说，也可以这样实例化：123$New = M('new','think_',$connection);// 等效于$New = new \Think\Model('new','think_',$connection); 具体的参数含义可以参考前面的介绍。 M方法实例化的时候，默认情况下是直接实例化系统的\Think\Model类，如果希望实例化其他的公共模型类的话，可以使用如下方法：123$User = M('\Home\Model\CommonModel:User','think_','db_config');// 相当于 $User = new \Home\Model\CommonModel('User','think_','db_config'); 如果模型类有自己的业务逻辑，M方法是无法支持的，就算是已经定义了具体的模型类，M方法实例化的时候是会直接忽略。 区别与联系 D方法实例化模型类的时候通常是实例化某个具体的模型类，如果仅仅是对数据表进行基本的CURD操作的话，使用M方法实例化的话，由于不需要加载具体的模型类，所以性能会更高。 D方法包含M方法。 ThinkPHP3.2.3模型实例化]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--SSH的使用]]></title>
    <url>%2F2017%2F04%2F28%2FHexo-SSH%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SSH keys - 让本地git项目与远程的github建立联系。 这篇博客主要介绍 SSH 的生成、生成多个 SSH 。 首次生成SSH检查SSH keys的设置首先需要检查电脑上现有的ssh key： 1$ cd ~/. ssh 检查本机的ssh密钥 如果提示：No such file or directory 说明是在当前电脑上第一次使用git。 生成新的SSH Key：123$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 注意1: 此处的邮箱地址，可以输入自己的邮箱地址； 注意2: 此处的 C 的是大写的 C ； 然后系统会要输入密码： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示输入一个密码，这个密码会在提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往项目里提交内容。 注意：输入密码的时候没有 * 字样的，直接输入就可以了。 添加SSH Key到GitHub在本机设置 SSH Key 之后，需要添加到 GitHub 上，以完成 SSH 链接的设置。 1、打开本地 C:\Documents and Settings\Administrator\.ssh\id_rsa.pub 文件。此文件里面内容为刚才生成人密钥。如果看不到这个文件，需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 2、登陆 github 系统。点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys 3、把本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了 测试可以输入下面的命令，看看设置是否成功，`git@github.com` 的部分不要修改： 1$ ssh -T git@github.com 如果是下面的反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 不要紧张，输入 yes 就好，然后会看到： 1Hi xxx! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 生成多个shh1.生成指定名字的密钥ssh-keygen -t rsa -C &quot;邮箱地址&quot; -f ~/.ssh/github_jslite 会生成 github_jslite 和 github_jslite.pub 这两个文件 2.密钥复制到托管平台上vim ~/.ssh/github_jslite.pub 打开公钥文件 github_jslite.pub ，并把内容复制至代码托管平台上 3.修改config文件vim ~/.ssh/config #修改config文件，如果没有创建 config 123456789Host jslite.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_jsliteHost abc.github.comHostName github.comUser gitIdentityFile ~/.ssh/github_abc 添加到博客的config文件中1git remote add origin git@jslite.github.com:JSLite/JSLite.git 4.测试ssh -T git@jslite.github.com # @后面跟上定义的 Host。 此部分摘自SegmentFault小弟调调的回答。]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO--绑定域名&公益404页面]]></title>
    <url>%2F2017%2F04%2F28%2FHexo%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D-%E5%85%AC%E7%9B%8A404%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[这篇博客主要是记录 Hexo 绑定域名和添加腾讯404公益页面。 绑定域名 所需材料： 1.域名 - 已在 godaddy 购买。 2.DNSpod账号 - 免费注册或者使用QQ登录。​ 建立CNAME文件在根目录下的 source 目录下创建一个 CNAME 文件，不带后缀，在文件中写入域名 lql.life。 可通过编辑器创建或者在git中输入 touch CNAME -&gt; vim CNAME ，然后按 i 输入 lql.life，按 Esc 再输入 :wq 回车即可。 最后一步是 hexo g -d 生成本地静态页面并部署到github的仓库上。 记录博客的iP地址在git中输入 ping Mine-MuYan.github.io 使用DNSpod解析域名DNSpod解析域名这里使用DNSpod来进行解析, 原因：很快，免费。 登录DNSpod：可以直接用QQ可以登录点击进入添加记录页面在DNSPod中添加“A记录”，注意要添加带“www”的和不带“www”两个记录,分别是@和www的ip都填之前解析出来的github网站ip。 godaddy设置DNS在godaddy的设置域名的DNS把域名服务器改成下面两个。 f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net，等待一会，访问 lql.life 就可。 整体预览这是当访问域名可以访问到博客时的域名DNS管理页面。 设置404页面腾讯404页面的作用：1.当访问到站内不存在的页面时，会跳转此页，比github的404页面好看些； 2.腾讯公益404页面，寻找丢失儿童，让大家一起关注此项公益事业！ 操作说明新建 404.html 页面，放到主题目录下的 source 目录下，内容如下：123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回博客主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后一步是 hexo g -d 生成本地静态页面并部署到github的仓库上。 技术支持 注意1.只能在绑定顶级域名的情况下，404页面才能生效； 2.本地 http://localhost:4000 不生效。 文档参考 JasonYu的博客 域名绑定 遇见西门 插件和主题优化]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo--在另一台电脑上写博客]]></title>
    <url>%2F2017%2F04%2F27%2FHexo-%E5%9C%A8%E5%8F%A6%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[换了个电脑写博客，把之前电脑的Hexo备份了一下，但是主题没备份，这次是重装Hexo，重新安装NexT主题。 2018年3月底 第三次重装后重新整理，地址：Hexo重装与位置移动 安装HEXO安装前准备 这些步骤是正常的安装HEXO的步骤。 在当前电脑上安装好git和nodejsgit是必须要安装的，安装nodejs是为了安装hexo方便。 添加SSH-Key到github上先进行全局配置12git config --global user.email &quot;xiao7shuang@qq.com&quot;git config --global user.name &quot;iSelly&quot; 生成ssh 1ssh-keygen -t rsa -C &quot;xiao7shuang@qq.com&quot; 第一次回车是选择ssh生成的路径，直接按回车，默认生成在C盘下，可以自己自定义，注意盘符要大写； 第二次回车是设置ssh的密码，如果直接按回车，在 hexo d 时，不用输密码即可部署到github上，如果设置了密码，则需要输入密码后才可以部署到github上。如果忘记了密码，貌似不能找回，只能重新生成ssh。 添加SSH到github上 用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key 验证 1ssh -T git@github.com 然后输入yes SSH的使用 正式安装hexo 1npm install -g hexo 然后，执行init命令初始化hexo到指定的目录 1hexo init &lt;folder&gt; 也可以cd到目标目录，执行hexo init 至此，全部安装工作已经完成。 在hexo init目录下用hexo s测试是否正常 参考地址 hexo你的博客 迁移HEXO1：将根目录下的_config.yml覆盖掉当前文件 2：把source文件夹覆盖掉当前文件夹 安装next主题1：下载/克隆最新版 cd your-hexo-site git clone https://github.com/iissnan/hexo-theme-next themes/next 或者去https://github.com/iissnan/hexo-theme-next/releases 下载，解压所下载的压缩包至站点的themes目录下，并将解压后的文件夹名称hexo-theme-next-0.4.0更改为next。 参考地址 NexT–开始使用 2：启用主题 与所有Hexo主题启用的模式一样。当克隆/下载完成后，打开站点配置文件， 找到theme字段，并将其值更改为next。 要修改的地方High一下将音乐放在themes/next/source/music文件夹下 在themes/next/layout/_partials/header.swig的64行添加代码 High.js sidebar的网易云音乐在themes/next/layout/_macro/sidebar.swig的95行加入： 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&amp;id=601795690&amp;auto=0&amp;height=430"&gt;&lt;/iframe&gt; 预览效果要先hexo clean -&gt; hexo g 才可以，不然一直显示不出来。 注意在hexo d 时： 如果出现 error deployer not found:git 的报错 这是因为 hexo 3.0 不适配 hexo 2.0 的bug 执行: npm install hexo-deployer-git --save 即可]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F03%2F09%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[我每天使用 git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库第一部分一、新建代码库 12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive 第二部分查看、添加、提交、删除、找回，重置修改文件12345678910111213141516171819202122232425262728293031git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci .git ci -a# 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff1234567891011git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录1234567git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息 tigMac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支1234567891011121314151617181920212223git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase123456git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)12345git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理1234567git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区 Git远程分支管理1234567891011121314151617181920212223git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理123456789git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库12345678910111213141516171819git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支也可以命令设置跟踪远程库和本地库git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop 参考资料阮一峰的网络日志:常用 Git 命令清单思考的足迹:Git常用命令Pro Git book]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术大牛养成指南，一篇不鸡汤的成功学实践]]></title>
    <url>%2F2017%2F03%2F08%2F%E6%8A%80%E6%9C%AF%E5%A4%A7%E7%89%9B%E5%85%BB%E6%88%90%E6%8C%87%E5%8D%97%EF%BC%8C%E4%B8%80%E7%AF%87%E4%B8%8D%E9%B8%A1%E6%B1%A4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AD%A6%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[有的人想成为大牛，却不曾为此努力。有的人辛苦耕耘，却收获寥寥。很多时候，你跟成功的差距并不是能力，也不是运气，或许只是正确的方法？这是一篇不鸡汤的成功学指南，如果你相信且愿意坚持尝试，未必帮不到你！ 1 一碗有勺子的鸡汤 我工作已经将近12年了（其实12年才混到这个地步，天资实在是一般），在华为做了5年，在UC做了6年，现在主要负责阿里游戏的中间件和组件的架构设计和实现，包括用户消息推送、系统异步通知系统等等。 同时我还带了三四十人的研发团队，除了工作以外，我也喜欢写博客，是CSDN、云栖的社区之星和博客专家，InfoQ的签约作者。 总体上来说，我现在虽然还算不上业界顶级的大牛，但在公司也算一头小牛了，今天我的分享将综合自己的成长经历给大家谈一谈怎么样成为一个大牛。我现在还在业界的大牛路上狂奔，但我觉得这些经验和技巧应该是每个同学都可以用到自己的日常工作和生活当中的。 2 一鸣惊人背后是1万小时的不断练习 如何成为大牛？这个问题之前有很多人问我：你是怎么成为技术上的一个大牛的？ 最开始的时候我也经常跟他们讲你要去看看某某某开发方案，深入学习UNIX的开发等等这些“术”的东西，后来我在思考，是否有成为一种大牛的“道”上面的东西，也就是说不管你做产品、做运营、做运维、程序员还是测试，通过这个方式都能够成为一个大牛呢？ 通过寻找和思考，后来真的让我找到了应用到所有行业、所有职业我称之为成为大牛的一个道，这是1万小时理论。 我先简单介绍一下1万小时理论，我最初看到1万小时理论是从《异类》这本书知道的，这是很出名的书，它非常有意思，我建议所有同学都去看一下，它分析了很多成功人士背后一些我们通常情况下不了解或没看到的一些现象，得出一些比较令人震撼的结论，其中有一个理论就是1万小时理论。 它里面有举了一些例子，比如说莫扎特，大家都知道他是音乐神童，6岁就开始作曲了，你看完这本书就知道他真正出人头地是20多岁的时候，也就是说他虽然6岁开始作曲，但他当时作的曲也是比较不好的。 所以《异类》这本书里面提到了1万小时的理论，它对我是很有帮助的，成为世界上顶级的专家唯一的方法就是1万小时持续不断地进行练习，大家要特别注意 “唯一” ，也就是说绝大部分专业是没有什么天才的，所谓的天才只是他一鸣惊人之后我们才这样觉得，在他成为天才之前至少要经过1万小时持续不断的练习。 我第一次看到1万小时的理论，觉得没什么神奇的，我算了算，我工作五年就会成为业界顶级的专家了，但想想这是不可能的，为什么呢？我反思了一下我自己的工作状态，对于大部分人来说每天的工作很多时候是重复劳动，虽然我们一天工作8小时，但是只是重复以往的经验，并没有刻意去训练提升自己。 有一个笑话是有一个10年工作经验的人去面试，面试完了之后面试官跟他说其实你只有1年工作经验，你把它重复了9年。 对于1万小时理论来说如果你深入思考其实它并没有那么简单，这意味着什么呢？意味着你每天要花3小时时间用于提升自己的技能，这样一直做，要持续大约10年时间。大家想想每天持续十年去做一件事情去提升自己，有几个能做到，所以我们看到虽然有些人工作了10年，但是也不一定能成为业界的专家。 为什么我要强调每天3小时？持续10年提升自己，你不能把你重复的工作算进去，你要在专业广度和深度上面不断扩展，才能业界一个顶尖的大牛或者专家。 举一个例子，一个小孩子每天唱《两只老虎》，唱10年，你觉得他会成为周杰伦吗？肯定不会。当然1万小时理论不适合一些领域，尤其是不适合炒股，特别是中国的股市，如果你花1万小时去炒股，可能会倾家荡产。 3 如何找到10000小时？ 碎片化时间管理 1万小时理论听起来好像很简单，每天持续3小时，也不难，但实际上真正做起来是很难的，就像我们互联网的人加班加成狗，感觉身体天天被掏空，时间从哪来，这是一个现实问题，不要说每天抽3个小时提升自己，每天抽1个小时陪女朋友或者找女朋友的时间都不够。具体怎么做？ 首先是找到3个30分钟： 第一个30分钟就是早上的30分钟，假设你习惯8点起床，明天你把闹钟改成7点半，这就多了半个小时。 第二个30分钟是睡觉前的30分钟，假设你习惯玩游戏到12点，明天晚上你玩游戏就玩到11点半。 第三个30分钟就是上班到你座位上的30分钟，有的同学担心说我这30分钟会不会影响我这一天的工作效率，可能加班完不成，还让我挤出30分钟来，这不用担心，从我的经历来看挤30分钟不会影响你整体的工作效率，持续一两年，你会发现自己的收益非常大。 第二点是利用或节省路途时间 我们每天上下班都是一两个小时，比如像我这种，怎么去利用时间呢？ 首先是可以利用上下班路上的时间去看书、听书，也是可以做的。如果你觉得上班路上是不能看书的，或者是不可能学习的，比如你坐广州的3号线，这是举世闻名的挤得要命的，不要说看书了，把手伸出去都不知道去哪了，那就建议大家搬到离公司近一点位置，虽然每个月多几百块钱的房租，但是你要相信这个投资节省下来的时间用于提升自己，它最终的收益是10倍回报都不止的。 第三点是周末4小时 周末还是不用怎么加班的，周末用于放松、睡觉、看电影、娱乐，你也可以在周末里面规定自己挤出4个小时，也就是每天2个小时，这样算下来，一天大概就两个多小时，再加上你在工作中的积累，每天3小时也不是很难。 接下来讲一下我是怎么做的，我现在有2个小孩，而且我住的比较远，应该在座的比我忙的也不会很多，看一下我是怎么做的，我是坐广州的四号线，坐四号线每天来回可以看一个小时的书，每天早晚30分钟，周末4小时，有的同学可能会有疑问，周末肯定要带小孩玩，自己也要休息，哪里有4个小时，其实只要你去找，时间都会有的，我找的方法就是当我小孩睡觉的时候，因为小孩子睡觉一般要睡三四个小时，大人一般睡一个小时、半个小时就差不多了，所以通过这种方式，大家可以看到2015年我一共看了84本书，有专业的，也有非专业的，人文社科、历史这些都有。 不过特别提醒一下对于男程序员来说有一个时间千万不能少，就是陪女朋友的时间，因为对程序员来说找女朋友不容易，别看了这篇文章回去之后女朋友也不要了，就天天回去提升，这也不是我们想要的生活。 4 10000小时理论如何轻松落地？ 虽然理论上很简单，但真正要落地实行也并不那么容易，实行10000小时理论的关键在于坚持，我认为坚持的关键在于自己对于所从事的事业是否有“激情和兴趣”。这点当然是核心，但如果只靠激情支撑，持续10年也确实有挑战，正如一个朋友在分享会后问我的“要持续10年才能成为大牛啊，时间好长啊”！ 如果说做一件事要10年后才能修成正果，估计很多朋友就会放弃了，毕竟像唐僧那么坚定的信仰者总是少数，大部分凡夫俗子都还是需要持续不断的激励才能有动力去做一件事，因为我们的大脑在进化的过程中已经形成了需要持续不断的奖励才能保持兴奋的机制，也就是说相对于在第10年给一个大奖励，还不如每年给一个小奖励。 那如何才能在10年漫长的路上让我们持续的坚持下去呢？答案其实就是首富的话：“先定一个能达到的小目标”！我们来看如何将“10年成为大牛”这个目标分解为一个个能达到的小目标。我将这个方法归纳为“三段分解法”，即：将一个宏大或者长远的目标经过3次分解，得到一个个短期内能达到的小目标。具体的分解方法如下。 一段分解：分解“等级” 10年成为大牛的目标虽然比较长远比较宏大，但并不意味着在没有成为大牛前，我们一直都是菜鸟。从菜鸟到大牛的过程中，中间其实有几个关键的里程碑，这些里程碑就是我们的一段目标。 以技术人员为例，技术人员典型的发展路径基本上都是下面的这个模式： 1） 0 ~ 1年：菜鸟，需要别人手把手来教 2）1 ~ 3年：初级，需要别人带你做 3）3 ~ 5年：高级，能独当一面，可以带初级技术人员了 4）5 ~ 8年：资深，能独挡多面 5）8 ~ 10年：大牛，统筹规划，高屋建瓴 通过上面的分解我们可以看到，虽然说10年才能成为大牛，但是3年就可以达到初级水平，5年就可以达到高级水平，8年就可以达到资深水平，在这个过程中我们一直在成长和提升，而不是说没有成为大牛就是菜鸟；并且对于很多朋友来说，如果目标不是像首富那样要赚就赚1亿，能达到高级或者资深水平，其实已经可以过得比较滋润了。 通过这种分解方法，再核对一下自己目前所处的位置，然后先瞄准下一个目标，全力以赴其实也就2 ~ 3年时间，这样来看一段目标其实是比较容易达成的。这种目标分解的方法除了适合技术人员外，其它很多领域也都适应，比如说产品人员、运营人员、甚至公务员！ 二段分解：分解“技能” 经过一段分解后，明确自己目前所处的位置和下一个目标，接下来就要看这个一段目标如何实现了。虽然说每个一段目标持续时间在 2~3年，但3年时间说长不长，说短也不短，如果没有好好利用，可能到了2年多的时候回头一看，好像什么都没达成，还是原地踏步。因此，为了更好的利用这3年时间，我们需要进一步分解，这就是“二段分解”。 一段分解的维度是等级，二段分解的维度则不一样，不能再分等级了，否则等级太细就没法区别了。二段分解的维度变成了“技能”，即：为了达到一段目标，我需要具备什么样的技能。 还是以技术人员为例，假设经过自我评估，认为自己目前处于初级阶段，而且初级阶段的事情已经做得比较顺手和熟练了，那么下一个一段目标自然就是达到“高级”水平。“高级”与“初级”相比，有哪些不同的技能要求呢？ 这就需要我们根据各自不同的行业和方向详细列出来了，如果自己想不出来，网上有很多资料都可以搜索到，最方便的就是到一个招聘网站，多看看几个招聘需求的描述，然后归纳总结一下。 我们随便到网上搜索一个，例如拉勾网上滴滴的“高级Java开发工程师”招聘： 多看几个类似的职位招聘，基本上我们就能明白“高级Java开发工程师”的一些基本要求。当然实际上的技能要求比招聘需求的描述还要更加细致，我个人的习惯是将这些要求整理为一个思维导图，详细列出每个技术点。例如： 注意：以上这个图只是示例，并不是说所有Java高级工程师都一定是这个要求，例如互联网行业和电信行业的要求不一样） 有了这样一个思维导图后，我们就可以开始真正进行二段分解了，分解的方法很简单：哪里不懂补哪里！例如：我感觉目前我的数据库水平一般，仅仅会写CRUD语句，其它的东西都不懂，那我就开始专攻数据库这一部分，经过一段时间的专攻来提升自己的水平。 二段目标持续时间一般建议是6个月，既不能太短也不能太长。太短容易让人陷入为了目标而做的误区，没有真正得到有效提升；时间太长的话，3年时间又不够完成其它目标了，例如要是我定一个目标说2年提升数据库，那操作系统怎么办？网络怎么办？……等等。以6个月为一个周期，基本上刚刚好。 经过分解，最终的二段目标可以分解为如下的几个更小的目标： 1）2016.06 ~ 2017.01：提升数据库水平 2）2017.01 ~ 2017.06：提升Linux水平 3）2017.06 ~ 2017.12：提升网络和网络编程水平 当然，二段分解目标并不是一成不变的，很多时候需要根据我们工作的内容进行调整。例如老大正好安排我来负责优化系统性能，降低机器负载，那么我完全可以将“提升Linux水平”安排到“提升数据库水平”之前。 三段分解：分解“行动” 二段分解得到技能的小目标后，接下来的关键就是要实现这个目标，这就是三段分解的主要目的，即：将技能目标分解为具体要做的事情，然后按照计划执行。 比如说我的二段目标是“提升Linux水平”，那怎么样才能提升呢？可以上网搜索（知乎是个好地方），也可以去问有经验的朋友。明确要做的事情后，三段分解需要将二段分解的6个月目标更加细化，分为1个月或者两个月一个目标。 以我当时加入UC的情况为例，我在华为的时候是在Windows平台上用VC6进行开发，而到了UC的时候是在Linux平台上用C++开发，我当时定了“提升Linux水平”的目标，然后通过上网查，找别人问等方法，最终将这个目标分解为几个步骤： 1）1个月：通读《UNIX环境高级编程》 2）1个月：通读《Linux系统编程》 3）2个月：通读《UNIX网络编程 卷1》 4）1个月：Linux常用命令实战：tcpdump、ps、top等 通过这种方法，将6个月的目标又进一步分解为1个月的目标，实施起来就简单多了，每1 ~ 2个月专注一个具体目标，每次完成后都很有成就感，既感觉自己的水平有了提升，又佩服自己能够坚持按计划按目标完成任务，双重奖赏让自己更有动力进行下一个目标。 我大约花了2年的时间将Linux、网络、MySQL三个重点技能从一无所知提升到高级的水平，很多同事都问我之前在华为是不是就是做这方面的，因为他们觉得短时间能达到这个水平是不太可能的。 综合前面的分析，我们将三段分解提炼一下：一段分解“等级”，二段分解“技能”，三段分解“行动”。通过前面我们的案例就可以看出，原本一个宏大的“10年成为技术大牛”的目标，经过三段分解，最终得到的是1 ~ 2个月可执行的具体行动，通过这种一步一个脚印的行动，最终就可以达成“10年成为技术大牛”的目标。 5 天天写业务代码，如何成为技术大牛？ 几个典型的误区 拜大牛为师 知乎上有人认为想成为技术大牛最简单直接、快速有效的方式是“拜团队技术大牛为师”，让他们平时给你开小灶，给你分配一些有难度的任务。我个人是反对这种方法的，主要的原因有几个： 大牛很忙，不太可能单独给你开小灶，更不可能每天都给你开1个小时的小灶；而且一个团队里面，如果大牛平时经常给你开小灶，难免会引起其他团队成员的疑惑，我个人认为如果团队里的大牛如果真正有心的话，多给团队培训是最好的。然而做过培训的都知道，准备一场培训是很耗费时间的，课件和材料至少2个小时（还不能是碎片时间），讲解1个小时，大牛们一个月做一次培训已经是很高频了。 因为第一个原因，所以一般要找大牛，都是带着问题去请教或者探讨。因为回答或者探讨问题无需太多的时间，更多的是靠经验和积累，这种情况下大牛们都是很乐意的，毕竟影响力是大牛的一个重要指标嘛。然而也要特别注意：如果经常问那些书本或者google能够很容易查到的知识，大牛们也会很不耐烦的，毕竟时间宝贵。经常有网友问我诸如“jvm的-Xmn参数如何配置”这类问题，我都是直接回答“请直接去google”，因为这样的问题实在是太多了，如果自己不去系统学习，每个都要问是非常浪费自己和别人的时间的。 大牛不多，不太可能每个团队都有技术大牛，只能说团队里面会有比你水平高的人，即使他每天给你开小灶，最终你也只能提升到他的水平；而如果是跨团队的技术大牛，由于工作安排和分配的原因，直接请教和辅导的机会是比较少的，单凭参加几次大牛的培训，是不太可能就成为技术大牛的。 综合上述的几个原因，我认为对于大部分人来说，要想成为技术大牛，首先还是要明白“主要靠自己”这个道理，不要期望有个像武功师傅一样的大牛手把手一步一步的教你。适当的时候可以通过请教大牛或者和大牛探讨来提升自己，但大部分时间还是自己系统性、有针对性的提升。 业务代码一样很牛逼 知乎上有的回答认为写业务代码一样可以很牛逼，理由是业务代码一样可以有各种技巧，例如可以使用封装和抽象使得业务代码更具可扩展性，可以通过和产品多交流以便更好的理解和实现业务，日志记录好了问题定位效率可以提升10倍……等等。 业务代码一样有技术含量，这点是肯定的，业务代码中的技术是每个程序员的基础，但只是掌握了这些技巧，并不能成为技术大牛，就像游戏中升级打怪一样，开始打小怪，经验值很高，越到后面经验值越少，打小怪已经不能提升经验值了，这个时候就需要打一些更高级的怪，刷一些有挑战的副本了，没看到哪个游戏只要一直打小怪就能升到顶级的。 成为技术大牛的路也是类似的，你要不断的提升自己的水平，然后面临更大的挑战，通过应对这些挑战从而使自己水平更上一级，然后如此往复，最终达到技术大牛甚至业界大牛的境界，写业务代码只是这个打怪升级路上的一个挑战而已，而且我认为是比较初级的一个挑战。 所以我认为：业务代码都写不好的程序员肯定无法成为技术大牛，但只把业务代码写好的程序员也还不能成为技术大牛。 上班太忙没时间自己学习 很多人认为自己没有成为技术大牛并不是自己不聪明，也不是自己不努力，而是中国的这个环境下，技术人员加班都太多了，导致自己没有额外的时间进行学习。 这个理由有一定的客观性，毕竟和欧美相比，我们的加班确实要多一些，但这个因素只是一个需要克服的问题，并不是不可逾越的鸿沟，毕竟我们身边还是有那么多的大牛也是在中国这个环境成长起来的。 我认为有几个误区导致了这种看法的形成： 1）上班做的都是重复工作，要想提升必须自己额外去学习 形成这个误区的主要原因还是在于认为“写业务代码是没有技术含量的”，而我现在上班就是写业务代码，所以我在工作中不能提升。 2）学习需要大段的连续时间 很多人以为要学习就要像学校上课一样，给你一整天时间来上课才算学习，而我们平时加班又比较多，周末累的只想睡懒觉，或者只想去看看电影打打游戏来放松，所以就没有时间学习了。 正确的做法正好相反： 首先我们应该在工作中学习和提升，因为学以致用或者有实例参考，学习的效果是最好的；其次工作后学习不需要大段时间，而是要挤出时间，利用时间碎片来学习。（参照前文10000小时理论） 正确的做法 Do more 做的更多，做的比你主管安排给你的任务更多。 我在HW的时候，负责一个版本的开发，这个版本的工作量大约是2000行左右，但是我除了做完这个功能，还将关联的功能全部掌握清楚了，代码（大约10000行）也全部看了一遍，做完这个版本后，我对这个版本相关的整套业务全部很熟悉了。经过一两次会议后，大家发现我对这块掌握最熟了，接下来就有趣了：产品讨论需求找我、测试有问题也找我、老大对外支撑也找我；后来，不是我负责的功能他们也找我，即使我当时不知道，我也会看代码或者找文档帮他们回答……最后我就成了我这个系统的“专家”了。虽然这个时候我还是做业务的，还是写业务代码，但是我已经对整个业务都很熟悉了。 以上只是一个简单的例子，其实就是想说：要想有机会，首先你得从人群中冒出来，要想冒出来，你就必须做到与众不同，要做到与众不同，你就要做得更多！ 怎么做得更多呢？可以从以下几个方面着手： 1）熟悉更多业务，不管是不是你负责的；熟悉更多代码，不管是不是你写的 这样做有很多好处，举几个简单的例子： 需求分析的时候更加准确，能够在需求阶段就识别风险、影响、难点 问题处理的时候更加快速，因为相关的业务和代码都熟悉，能够快速的判断问题可能的原因并进行排查处理 方案设计的时候考虑更加周全，由于有对全局业务的理解，能够设计出更好的方案 2）熟悉端到端 比如说你负责web后台开发，但实际上用户发起一个http请求，要经过很多中间步骤才到你的服务器（例如浏览器缓存、DNS、nginx等），服务器一般又会经过很多处理才到你写的那部分代码（路由、权限等）这整个流程中的很多系统或者步骤，绝大部分人是不可能去参与写代码的，但掌握了这些知识对你的综合水平有很大作用，例如方案设计、线上故障处理这些更加有含金量的技术工作都需要综合技术水平。 “系统性”、“全局性”、“综合性”这些字眼看起来比较虚，但其实都是技术大牛的必备的素质，要达到这样的境界，必须去熟悉更多系统、业务、代码。 3）自学 一般在比较成熟的团队，由于框架或者组件已经进行了大量的封装，写业务代码所用到的技术确实也比较少，但我们要明白“唯一不变的只有变化”，框架有可能要改进，组件可能要替换，现有技术可能已经无法满足业务需求，或者你换了一家公司，新公司既没有组件也没有框架，要你从头开始来做。这些都是机会，也是挑战，而机会和挑战只会分配给有准备的人，所以这种情况下我们更加需要自学更多东西，因为真正等到要用的时候再来学已经没有时间了。 以java为例，大部分业务代码就是if-else加个数据库操作，但我们完全可以自己学些更多java的知识，例如垃圾回收，调优，网络编程等，这些可能暂时没用，但真要用的时候，不是google一下就可以了，这个时候谁已经掌握了相关知识和技能，机会就是谁的。 以垃圾回收为例，我自己平时就抽时间学习了这些知识，学了1年都没用上，但后来用上了几次，每次都解决了卡死的大问题，而有的同学，写了几年的java代码，对于stop-the-world是什么概念都不知道，更不用说去优化了。 特别是很多开源软件，更加需要自己平时去自学，例如Nginx、Redis、Mongodb、ElasticSearch等，在合适的时机引入这些技术，能够带来很大的价值。 Do better 要知道这个世界上没有完美的东西，你负责的系统和业务，总有不合理和可以改进的地方，这些“不合理”和“可改进”的地方，都是更高级别的怪物，打完后能够增加更多的经验值。识别出这些地方，并且给出解决方案，然后向主管提出，一次不行两次，多提几次，只要有一次落地了，这就是你的机会。 例如： 重复代码太多，是否可以引入设计模式？ 系统性能一般，可否进行优化？ 目前是单机，如果做成双机是否更好？ 版本开发质量不高，是否引入高效的单元测试和集成测试方案？ 目前的系统太庞大，是否可以通过重构和解耦改为3个系统？ 阿里中间件有一些系统感觉我们也可以用，是否可以引入 ？ 只要你去想，其实总能发现可以改进的地方的；如果你觉得系统哪里都没有改进的地方，那就说明你的水平还不够，可以多学习相关技术，多看看业界其它公司怎么做，BAT都怎么做。 我2013年调配到九游，刚开始接手了一个简单的后台系统，每天就是配合前台做数据增删改查，看起来完全没意思，是吧？如果只做这些确实没意思，但我们接手后做了很多事情： 解耦，将一个后台拆分为2个后台，提升可扩展性和稳定性； 双机，将单机改为双机系统，提高可靠性； 优化，将原来一个耗时5小时的接口优化为耗时5分钟 还有其它很多优化，后来我们这个组承担了更多的系统，后来这个小组5个人，负责了6个系统。 Do exercise 在做职业等级沟通的时候，发现有很多同学确实也在尝试Do more、Do better，但在执行的过程中，几乎每个人都遇到同一个问题：光看不用效果很差，怎么办？ 例如： 学习了jvm的垃圾回收，但是线上比较少出现FGC导致的卡顿问题，就算出现了，恢复业务也是第一位的，不太可能线上出现问题然后让每个同学都去练一下手，那怎么去实践这些jvm的知识和技能呢？ Netty我也看了，也了解了Reactor的原理，但是我不可能参与Netty开发，怎么去让自己真正掌握Reactor异步模式呢？ 看了《高性能MySQL》，但是线上的数据库都是DBA管理的，测试环境的数据库感觉又是随便配置的，我怎么去验证这些技术呢？ 框架封装了DAL层，数据库的访问我们都不需要操心，我们怎么去了解分库分表实现？ 诸如此类问题还有很多，我这里分享一下个人的经验，其实就是3个词：learning、trying、teaching！ 1）Learning 这个是第一阶段，看书、google、看视频、看别人的博客都可以，但要注意一点是“系统化”，特别是一些基础性的东西，例如JVM原理、Java编程、网络编程，HTTP协议。。。。。。等等，这些基础技术不能只通过google或者博客学习，我的做法一般是先完整的看完一本书全面的了解，然后再通过google、视频、博客去有针对性的查找一些有疑问的地方，或者一些技巧。 2）Trying 这个步骤就是解答前面提到的很多同学的疑惑的关键点，形象来说就是“自己动手丰衣足食”，也就是自己去尝试搭建一些模拟环境，自己写一些测试程序。例如： Jvm垃圾回收：可以自己写一个简单的测试程序，分配内存不释放，然后调整各种jvm启动参数，再运行的过程中使用jstack、jstat等命令查看jvm的堆内存分布和垃圾回收情况。这样的程序写起来很简单，简单一点的就几行，复杂一点的也就几十行。 Reactor原理：自己真正去尝试写一个Reactor模式的Demo，不要以为这个很难，最简单的Reactor模式代码量（包括注释）不超过200行（可以参考Doug Lee的PPT）。自己写完后，再去看看netty怎么做，一对比理解就更加深刻了。 MySQL：既然有线上的配置可以参考，那可以直接让DBA将线上配置发给我们（注意去掉敏感信息），直接学习；然后自己搭建一个MySQL环境，用线上的配置启动；要知道很多同学用了很多年MySQL，但是连个简单的MySQL环境都搭不起来。 框架封装了DAL层：可以自己用JDBC尝试去写一个分库分表的简单实现，然后与框架的实现进行对比，看看差异在哪里。 用浏览器的工具查看HTTP缓存实现，看看不同种类的网站，不同类型的资源，具体是如何控制缓存的；也可以自己用Python写一个简单的HTTP服务器，模拟返回各种HTTP Headers来观察浏览器的反应。 还有很多方法，这里就不一一列举，简单来说，就是要将学到的东西真正试试，才能理解更加深刻，印第安人有一句谚语：I hear and I forget. I see and I remember. I do and I understand，而且“试试”其实可以比较简单，很多时候我们都可以自己动手做。 当然，如果能够在实际工作中使用，效果会更好，毕竟实际的线上环境和业务复杂度不是我们写个模拟程序就能够模拟的，但这样的机会可遇不可求，大部分情况我们还真的只能靠自己模拟，然后等到真正业务要用的时候，能够信手拈来。 3）Teaching 一般来说，经过Learning和Trying，能掌握70%左右，但要真正掌握，我觉得一定要做到能够跟别人讲清楚。因为在讲的时候，我们既需要将一个知识点系统化，也需要考虑各种细节，这会促使我们进一步思考和学习。同时，讲出来后看或者听的人可以有不同的理解，或者有新的补充，这相当于继续完善了整个知识技能体系。 这样的例子很多，包括我自己写博客的时候经常遇到，本来我觉得自己已经掌握很全面了，但一写就发现很多点没考虑到；组内培训的时候也经常看到，有的同学写了PPT，但是讲的时候，大家一问，或者一讨论，就会发现很多点还没有讲清楚，或者有的点其实是理解错了。写PPT、讲PPT、讨论PPT，这个流程全部走一遍，基本上对一个知识点掌握就比较全面了。 6 后记 成为技术大牛梦想虽然很美好，但是要付出很多，不管是Do more还是Do better还是Do exercise，都需要花费时间和精力，这个过程中可能很苦逼，也可能很枯燥，这里我想特别强调一下：前面我讲的都是一些方法论的东西，但真正起决定作用的，其实还是我们对技术的热情和兴趣！ 摘自 InfoQ，作者：王烨]]></content>
      <categories>
        <category>鸡汤</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7个面向对象的好习惯]]></title>
    <url>%2F2017%2F02%2F28%2F7%E4%B8%AA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A5%BD%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[如果您尚未打算用OO原则创建应用程序，则使用 PHP 的面向对象（OO）的语言特性，这 7 个习惯将帮助您开始在过程编程与OO编程之间进行转换。 概述在 PHP 编程早期，PHP 代码在本质上是限于面向过程的。过程代码 的特征在于使用过程构建应用程序块。过程通过允许过程之间的调用提供某种程度的重用。 但是，没有面向对象的语言构造，程序员仍然可以把OO特性引入到 PHP 代码中。这样做有点困难并且会使代码难于阅读，因为它是混合范例（含有伪OO设计的过程语言）。使用 PHP 代码中的OO构造 — 例如能够定义和使用类、能够构建使用继承的类之间的关系以及能够定义接口 — 可以更轻松地构建符合优秀OO实践的代码。 虽然没有过多模块化的纯过程设计运行得很好，但是OO设计的优点表现在维护上。由于典型应用程序的大部分生命周期都花费在维护上，因此代码维护是应用程序生命周期的重要部分。并且在开发过程中代码维护很容易被遗忘。如果在应用程序开发和部署方面存在竞争，那么长期可维护性可能被放在比较次要的地位。 模块化— 优秀OO设计的主要特性之一 — 可以帮助完成这样的维护。模块化将帮助封装更改，这样可以随着时间的推移更轻松地扩展和修改应用程序。 总的来说，虽然构建OO软件的习惯不止 7 个，但是遵循这里的 7 个习惯可以使代码符合基本OO设计标准。它们将为您提供更牢固的基础，在此基础之上建立更多OO习惯并构建可轻松维护与扩展的软件。这些习惯针对模块化的几个主要特性。有关独立于语言的OO设计优点的更多信息，请参阅 参考资料。 7 个优秀 PHPOO习惯包括： 保持谦虚。 做个好邻居。 避免看到美杜莎。 利用最弱的链接。 您是橡皮；我是胶水。 限制传播。 考虑使用模式。 保持谦虚保持谦虚指避免在类实现和函数实现中暴露自己。隐藏您的信息是一项基本习惯。如果不能养成隐藏实现细节的习惯，那么将很难养成任何其他习惯。信息隐藏也称为_封装_。 直接公开公共字段是一个坏习惯的原因有很多，最重要的原因是让您在实现更改中没有应有的选择。使用OO概念隔离更改，而封装在确保所作更改在本质上不是病毒性（viral）更改方面扮演不可或缺的角色。病毒性 更改是开始时很小的更改 — 如将保存三个元素的数组更改为一个只包含两个元素的数组。突然，您发现需要更改越来越多的代码以适应本应十分微不足道的更改。 开始隐藏信息的一种简单方法是保持字段私有并且用公共访问方法公开这些字段，就像家中的窗户一样。并没有让整面墙都朝外部开放，而只打开一两扇窗户（我将在 “好习惯：使用公共访问方法” 中介绍访问方法的更多信息）。 除了允许您的实现隐藏在更改之后外，使用公共访问方法而非直接公开字段将允许您在基本实现的基础上进行构建，方法为覆盖访问方法的实现以执行略微不同于父方法的行为。它还允许您构建一个抽象实现，从而使实际实现委托给覆盖基本实现的类。 坏习惯：公开公共字段在清单 1 的坏代码示例中，Person 对象的字段被直接公开为公共字段而非使用访问方法。虽然此行为十分诱人，尤其对于轻量级数据对象来说更是如此，但是它将对您提出限制。 清单 1. 公开公共字段的坏习惯1234567891011121314151617&lt;?phpclass Person&#123; public $prefix; public $givenName; public $familyName; public $suffix;&#125;$person = new Person();$person-&gt;prefix = "Mr.";$person-&gt;givenName = "John";echo($person-&gt;prefix);echo($person-&gt;givenName);?&gt; 如果对象有任何更改，则使用该对象的所有代码也都需要更改。例如，如果某人的教名、姓氏和其他名字被封装到 PersonName 对象中，则需要修改所有代码以适应更改。 好习惯：使用公共访问方法通过使用优秀的OO习惯（参见清单 2），同一个对象现在拥有私有字段而非公共字段，并且通过称为访问方法 的 get 和 set 公共方法谨慎地向外界公开私有字段。这些访问方法现在提供了一种从 PHP 类中获取信息的公共方法，这样在实现发生更改时，更改使用类的所有代码的需求很可能变小。 清单 2. 使用公共访问方法的好习惯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpclass Person&#123; private $prefix; private $givenName; private $familyName; private $suffix; public function setPrefix($prefix) &#123; $this-&gt;prefix = $prefix; &#125; public function getPrefix() &#123; return $this-&gt;prefix; &#125; public function setGivenName($gn) &#123; $this-&gt;givenName = $gn; &#125; public function getGivenName() &#123; return $this-&gt;givenName; &#125; public function setFamilyName($fn) &#123; $this-&gt;familyName = $fn; &#125; public function getFamilyName() &#123; return $this-&gt;familyName; &#125; public function setSuffix($suffix) &#123; $this-&gt;suffix = $suffix; &#125; public function getSuffix() &#123; return $suffix; &#125;&#125;$person = new Person();$person-&gt;setPrefix("Mr.");$person-&gt;setGivenName("John");echo($person-&gt;getPrefix());echo($person-&gt;getGivenName());?&gt; 乍看之下，这段代码可能会完成大量工作，并且实际上可能更多是在前端的工作。但是，通常，使用优秀的OO习惯从长远来看十分划算，因为将极大地巩固未来更改。 在清单 3 中所示的代码版本中，我已经更改了内部实现以使用名称部件的关联数组。比较理想的情况是，我希望拥有错误处理并且更仔细地检查元素是否存在，但是本例的目的在于展示使用我的类的代码无需更改的程度 — 代码并没有察觉到类发生更改。记住采用OO习惯的原因是要谨慎封装更改，这样代码将更具有可扩展性并且更容易维护。 清单 3. 使用不同内部实现的另一个示例12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Person&#123; private $personName = array(); public function setPrefix($prefix) &#123; $this-&gt;personName['prefix'] = $prefix; &#125; public function getPrefix() &#123; return $this-&gt;personName['prefix']; &#125; public function setGivenName($gn) &#123; $this-&gt;personName['givenName'] = $gn; &#125; public function getGivenName() &#123; return $this-&gt;personName['givenName']; &#125; /* etc... */&#125;/* * Even though the internal implementation changed, the code here stays exactly * the same. The change has been encapsulated only to the Person class. */$person = new Person();$person-&gt;setPrefix("Mr.");$person-&gt;setGivenName("John");echo($person-&gt;getPrefix());echo($person-&gt;getGivenName());?&gt; 做个好邻居在构建类时，它应当正确地处理自己的错误。如果该类不知道如何处理错误，则应当以其调用者理解的格式封装这些错误。此外，避免返回空对象或者状态无效的对象。许多时候，只需通过检验参数并抛出特定异常说明提供参数无效的原因就可以实现这一点。在您养成这个习惯时，它可以帮您 — 和维护代码或使用对象的人员 — 节省很多时间。 坏习惯：不处理错误考虑清单 4 中所示的示例，该示例将接受一些参数并返回填充了一些值的 Person 对象。但是，在 parsePersonName() 方法中，没有验证提供的 $val 变量是否为空、是否是零长度字符串或者字符串是否使用无法解析的格式。parsePersonName() 方法不返回 Person 对象，但是返回 null。使用这种方法的管理员或程序员可能会觉得很麻烦 — 至少他们现在需要开始设置断点并调试 PHP 脚本。 清单 4. 不抛出或处理错误的坏习惯123456789101112131415&lt;?phpclass PersonUtils&#123; public static function parsePersonName($format, $val) &#123; if (strpos(",", $val) &gt; 0) &#123; $person = new Person(); $parts = split(",", $val); // Assume the value is last, first $person-&gt;setGivenName($parts[1]); $person-&gt;setFamilyName($parts[0]); &#125; return $person; &#125;&#125;?&gt; 清单 4 中的 parsePersonName() 方法可以修改为在 if 条件外部初始化 Person 对象，确保总是获得有效的 Person 对象。但是，您得到的是没有 set 属性的 Person，这仍然没有很好地改善您的困境。 好习惯：每个模块都处理自己的错误不要让调用方凭空猜测，而是对参数进行预先验证。如果未设置的变量无法生成有效的结果，请检查变量并抛出 InvalidArgumentException。如果字符串不能为空或者必须为特定格式，请检查格式并抛出异常。清单 5 解释了如何在演示一些基本验证的 parsePerson() 方法中创建异常以及一些新条件。 清单 5. 抛出错误的好习惯123456789101112131415161718&lt;?phpclass InvalidPersonNameFormatException extends LogicException &#123;&#125;class PersonUtils&#123; public static function parsePersonName($format, $val) &#123; if (! $format) &#123; throw new InvalidPersonNameFormatException("Invalid PersonName format."); &#125; if ((! isset($val)) || strlen($val) == 0) &#123; throw new InvalidArgumentException("Must supply a non-null value to parse."); &#125; &#125;&#125;?&gt; 最终目的是希望人们能够使用您的类，而不必了解其中的工作原理。如果他们使用的方法不正确或者不是按照期望的方法使用，也不需要猜测不能工作的原因。作为一个好邻居，您需要知道对您的类进行重用的人并没有特异功能，因此您需要解决猜测的问题。 避免看到美杜莎在我最初了解OO概念时，我十分怀疑接口是否真正有帮助。我的同事给我打了个比方，说不使用接口就好像看到美杜莎的头。在希腊神话中，美杜莎是长着蛇发的女怪。凡是看了她一眼的人都会变成石头。杀死美杜莎的珀尔休斯通过在盾上观察她的影子，避免了变成石头而得以与她对抗。 接口就是对付美杜莎的镜子。当您使用一个特定的具体实现时，代码也必须随着实现代码的更改而更改。直接使用实现将限制您的选择，因为您已经在本质上把类变成了 “石头”。 坏习惯：不使用接口清单 6 显示了从数据库中装入 Person 对象的示例。它将获取人员的姓名并返回数据库中匹配的 Person 对象。 清单 6. 不使用接口的坏习惯123456789101112131415161718192021&lt;?phpclass DBPersonProvider&#123; public function getPerson($givenName, $familyName) &#123; /* go to the database, get the person... */ $person = new Person(); $person-&gt;setPrefix("Mr."); $person-&gt;setGivenName("John"); return $person; &#125;&#125;/* I need to get person data... */$provider = new DBPersonProvider();$person = $provider-&gt;getPerson("John", "Doe");echo($person-&gt;getPrefix());echo($person-&gt;getGivenName());?&gt; 在环境发生更改之前，从数据库中装入 Person 的代码都可以正常运行。例如，从数据库装入 Person 可能适用于第一个版本的应用程序，但是对于第二个版本，可能需要添加从 Web 服务装入人员的功能。其实，该类已经变成 “石头”，因为它在直接使用实现类并且现在能做的更改十分有限。 好习惯：使用接口清单 7 显示了一个代码示例，在实现了加载用户的新方法后并没有进行更改。该示例显示了一个名为 PersonProvider 的接口，该接口将声明单个方法。如果任何代码使用 PersonProvider，代码都禁止直接使用实现类。相反，它就像是一个实际对象一样使用 PersonProvider。 清单 7. 使用接口的好习惯123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinterface PersonProvider&#123; public function getPerson($givenName, $familyName);&#125;class DBPersonProvider implements PersonProvider&#123; public function getPerson($givenName, $familyName) &#123; /* pretend to go to the database, get the person... */ $person = new Person(); $person-&gt;setPrefix("Mr."); $person-&gt;setGivenName("John"); return $person; &#125;&#125;class PersonProviderFactory&#123; public static function createProvider($type) &#123; if ($type == 'database') &#123; return new DBPersonProvider(); &#125; else &#123; return new NullProvider(); &#125; &#125;&#125;$config = 'database';/* I need to get person data... */$provider = PersonProviderFactory::createProvider($config);$person = $provider-&gt;getPerson("John", "Doe");echo($person-&gt;getPrefix());echo($person-&gt;getGivenName());?&gt; 在使用接口时，尝试避免直接引用实现类。相反，使用对象外部的内容可以提供正确的实现。如果您的类将装入基于某些逻辑的实现，它仍然需要获取所有实现类的定义，并且那样做也无法取得任何效果。 您可以使用 Factory 模式来创建实现接口的实现类的实例。根据约定，factory 方法将以 create 为开头并返回接口。它可以为您的 factory 获取必要的参数以计算出应当返回哪个实现类。 在清单 7 中，createProvider() 方法只是获取 $type。如果 $type 被设为 database，工厂将返回 DBPersonProvider 的实例。从数据库中装入人员的任何新实现都不要求在使用工厂和接口的类中进行任何更改。DBPersonProvider 将实现 PersonProvider 接口并且拥有 getPerson() 方法的实际实现。 利用最弱的链接将模块松散耦合 在一起是件好事情；它是允许您封装更改的属性之一。另外两个习惯 — “保持谨慎” 和 “避免看到美杜莎” — 可帮助您构建松散耦合的模块。要实现松散耦合的类，可通过养成降低类依赖关系的习惯实现。 坏习惯：紧密耦合在清单 8 中，降低依赖关系并不是必须降低使用对象的客户机的依赖关系。相反，该示例将演示如何降低与正确类的依赖关系并最小化这种依赖关系。 清单 8. Address 中紧密耦合的坏习惯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phprequire_once "./AddressFormatters.php";class Address&#123; private $addressLine1; private $addressLine2; private $city; private $state; // or province... private $postalCode; private $country; public function setAddressLine1($line1) &#123; $this-&gt;addressLine1 = $line1; &#125; /* accessors, etc... */ public function getCountry() &#123; return $this-&gt;country; &#125; public function format($type) &#123; if ($type == "inline") &#123; $formatter = new InlineAddressFormatter(); &#125; else if ($type == "multiline") &#123; $formatter = new MultilineAddressFormatter(); &#125; else &#123; $formatter = new NullAddressFormatter(); &#125; return $formatter-&gt;format($this-&gt;getAddressLine1(), $this-&gt;getAddressLine2(), $this-&gt;getCity(), $this-&gt;getState(), $this-&gt;getPostalCode(), $this-&gt;getCountry()); &#125;&#125;$addr = new Address();$addr-&gt;setAddressLine1("123 Any St.");$addr-&gt;setAddressLine2("Ste 200");$addr-&gt;setCity("Anytown");$addr-&gt;setState("AY");$addr-&gt;setPostalCode("55555-0000");$addr-&gt;setCountry("US");echo($addr-&gt;format("multiline"));echo("\n");echo($addr-&gt;format("inline"));echo("\n");?&gt; 在 Address 对象上调用 format() 方法的代码可能看上去很棒 — 这段代码所做的是使用 Address 类，调用 format() 并完成。相反，Address 类就没那么幸运。它需要了解用于正确格式化的各种格式化方法，这可能使 Address 对象无法被其他人很好地重用，尤其是在其他人没有兴趣在 format() 方法中使用格式化方法类的情况下。虽然使用 Address 的代码没有许多依赖关系，但是 Address 类却有大量代码，而它可能只是一个简单的数据对象。 Address 类与知道如何格式化 Address 对象的实现类紧密耦合。 好习惯：在对象之间松散耦合在构建优秀的OO设计时，必须考虑称为关注点分离（Separation of Concerns，SoC）的概念。SoC 指尝试通过真正关注的内容分离对象，从而降低耦合度。在最初的 Address 类中，它必须关注如何进行格式化。这可能不是优秀的设计。然而，Address 类应当考虑 Address 的各部分，而某种格式化方法应当关注如何正确格式化地址。 在清单 9 中，格式化地址的代码被移到接口、实现类和工厂中 — 养成 “使用接口” 的习惯。现在，AddressFormatUtils 类负责创建格式化方法并格式化 Address。任何其他对象现在都可以使用 Address 而不必担心要求获得格式化方法的定义。 清单 9. 在对象之间松散耦合的好习惯1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpinterface AddressFormatter&#123; public function format($addressLine1, $addressLine2, $city, $state, $postalCode, $country);&#125;class MultiLineAddressFormatter implements AddressFormatter&#123; public function format($addressLine1, $addressLine2, $city, $state, $postalCode, $country) &#123; return sprintf("%s\n%s\n%s, %s %s\n%s", $addressLine1, $addressLine2, $city, $state, $postalCode, $country); &#125;&#125;class InlineAddressFormatter implements AddressFormatter&#123; public function format($addressLine1, $addressLine2, $city, $state, $postalCode, $country) &#123; return sprintf("%s %s, %s, %s %s %s", $addressLine1, $addressLine2, $city, $state, $postalCode, $country); &#125;&#125;class AddressFormatUtils&#123; public static function formatAddress($type, $address) &#123; $formatter = AddressFormatUtils::createAddressFormatter($type); return $formatter-&gt;format($address-&gt;getAddressLine1(), $address-&gt;getAddressLine2(), $address-&gt;getCity(), $address-&gt;getState(), $address-&gt;getPostalCode(), $address-&gt;getCountry()); &#125; private static function createAddressFormatter($type) &#123; if ($type == "inline") &#123; $formatter = new InlineAddressFormatter(); &#125; else if ($type == "multiline") &#123; $formatter = new MultilineAddressFormatter(); &#125; else &#123; $formatter = new NullAddressFormatter(); &#125; return $formatter; &#125;&#125;$addr = new Address();$addr-&gt;setAddressLine1("123 Any St.");$addr-&gt;setAddressLine2("Ste 200");$addr-&gt;setCity("Anytown");$addr-&gt;setState("AY");$addr-&gt;setPostalCode("55555-0000");$addr-&gt;setCountry("US");echo(AddressFormatUtils::formatAddress("multiline", $addr));echo("\n");echo(AddressFormatUtils::formatAddress("inline", $addr));echo("\n");?&gt; 当然，缺点是只要使用模式，通常就意味着工件（类、文件）的数量会增加。但是，通过减少每个类中的维护可以弥补这个缺点，甚至在获得正确的可重用性时反而可以减少工件量。 您是橡皮；我是胶水具有高度内聚力的OO设计被集中并组织到相关模块中。了解 “关注点” 对于决定如何紧密地联系函数和类十分重要。 坏习惯：降低内聚力当设计的内聚力较低 时，它就不能良好地组织类和方法。意大利面条式代码（spaghetti code）一词通常用于描述捆绑在一起并且具有低内聚力的类和方法。清单 10 提供了意大利面条式代码的示例。相对通用的 Utils 类将使用许多不同对象并且有许多依赖关系。它执行很多操作，因而很难实现重用。 清单 10. 降低内聚力的坏习惯123456789101112131415161718192021222324252627282930&lt;?phpclass Utils&#123; public static function formatAddress($formatType, $address1, $address2, $city, $state) &#123; return "some address string"; &#125; public static function formatPersonName($formatType, $givenName, $familyName) &#123; return "some person name"; &#125; public static function parseAddress($formatType, $val) &#123; // real implementation would set values, etc... return new Address(); &#125; public static function parseTelephoneNumber($formatType, $val) &#123; // real implementation would set values, etc... return new TelephoneNumber(); &#125;&#125;?&gt; 好习惯：利用高内聚力高内聚力 指将相互关联的类和方法分组在一起。如果方法和类都具有高度的内聚力，则可以轻松地分解整个组而不影响设计。具有高内聚力的设计将提供降低耦合的机会。清单 11 显示了被较好组织到类中的两个方法。AddressUtils 类将包含用于处理 Address 类的方法，显示了与地址相关的方法之间的高度内聚力。同样地，PersonUtils 将包含专门处理 Person 对象的方法。这两个拥有高度内聚力方法的新类的耦合性都很低，因为可以完全独立地使用。 清单 11. 高内聚力的好习惯12345678910111213141516171819202122232425262728293031323334&lt;?phpclass AddressUtils&#123; public static function formatAddress($formatType, $address1, $address2, $city, $state) &#123; return "some address string"; &#125; public static function parseAddress($formatType, $val) &#123; // real implementation would set values, etc... return new Address(); &#125;&#125;class PersonUtils&#123; public static function formatPersonName($formatType, $givenName, $familyName) &#123; return "some person name"; &#125; public static function parsePersonName($formatType, $val) &#123; // real implementation would set values, etc... return new PersonName(); &#125;&#125;?&gt; 限制传播我经常对我所在的软件团队（我在其中担任技术主管或架构师）的成员提起，OO 语言最大的敌人是复制和粘贴操作。当在缺少预先OO设计的情况下使用时，没有任何操作会像在类之间复制代码那样具有破坏性。无论何时，如果想将代码从一个类复制到下一个类中，请停下来并考虑如何使用类层次结构利用类似功能或相同功能。在大多数情况下，使用优秀设计后，您将会发现完全没有必要复制代码。 坏习惯：不使用类层次结构清单 12 显示了部分类的简单示例。它们从重复的字段和方法开始 — 从长远来看，不利于应用程序作出更改。如果 Person 类中有缺陷，则 Employee 类中也很可能有一个缺陷，因为看上去似乎实现是在两个类之间复制的。 清单 12. 不使用层次结构的坏习惯1234567891011121314&lt;?phpclass Person&#123; private $givenName; private $familyName;&#125;class Employee&#123; private $givenName; private $familyName;&#125;?&gt; _继承_ 是一个很难入手的习惯，因为构建正确继承模型的分析通常需要花费大量时间。反过来，使用 Ctrl+C 组合键和 Ctrl+V 组合键构建新实现只需几秒钟。但是省下的这部分时间通常会在维护阶段迅速抵销掉，因为应用程序实际上将花费大量进行维护。 好习惯：利用继承在清单 13 中，新 Employee 类将扩展 Person 类。它现在将继承所有通用方法并且不重新实现这些方法。此外，清单 13 显示了抽象方法的用法，演示如何将基本功能放入基类中以及如何阻止实现类使用特定函数。 清单 13. 利用继承的好习惯123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpabstract class Person&#123; private $givenName; private $familyName; public function setGivenName($gn) &#123; $this-&gt;givenName = $gn; &#125; public function getGivenName() &#123; return $this-&gt;givenName; &#125; public function setFamilyName($fn) &#123; $this-&gt;familyName = $fn; &#125; public function getFamilyName() &#123; return $this-&gt;familyName; &#125; public function sayHello() &#123; echo("Hello, I am "); $this-&gt;introduceSelf(); &#125; abstract public function introduceSelf();&#125;class Employee extends Person&#123; private $role; public function setRole($r) &#123; $this-&gt;role = $r; &#125; public function getRole() &#123; return $this-&gt;role; &#125; public function introduceSelf() &#123; echo($this-&gt;getRole() . " " . $this-&gt;getGivenName() . " " . $this-&gt;getFamilyName()); &#125;&#125;?&gt; 考虑使用模式设计模式指对象和方法的常见交互，并且时间证明它可以解决某些问题。当您考虑使用设计模式时，您就需要了解类之间如何进行交互。它是构建类及其交互操作的简单方法，无需重蹈他人的覆辙，并从经过证明的设计中获益。 坏习惯：一次考虑一个对象实际上没有适当的代码示例可以演示如何考虑使用模式（尽管有丰富的优秀示例可以显示模式实现）。但是，一般而言，您知道在满足以下条件时一次只能考虑一个对象： 不会提前设计对象模型。 开始编写单一方法的实现，而无需去掉大部分模型。 在交谈中不使用设计模式名而宁愿谈论实现。 好习惯：同时添加模式中形成的对象一般而言，当您在执行以下操作时就是在考虑使用模式： 提前构建类及其交互操作。 根据模式套用类。 使用模式名，如 Factory、Singleton 和 Facade。 去掉大部分模型，然后开始添加实现。 结束语在 PHP 中养成良好的OO习惯将帮助您构建更稳定、更易于维护和更易于扩展的应用程序。记住： 保持谨慎。 做个好邻居。 避免看到美杜莎。 利用最弱的链接。 您是橡皮，我是胶水。 限制传播。 考虑使用模式。 当您养成并应用这些习惯后，您很可能会惊讶地发现应用程序在质量上的飞跃。 参考资料学习 您可以参阅本文在 developerWorks 全球站点上的 英文原文。 阅读 模块编程) 的维基百科条目。 阅读 Bertrand Meyer 所著的 Object-Oriented Software Construction 一书了解面向对象设计的更多信息。 访问官方 PHP Web 站点中关于 类和对象 的 PHP 手册内容。 阅读 “五种常见的 PHP 设计模式” 和 “另外五个 PHP 设计模式” 了解 PHP 中的设计模式。 PHP.net 是 PHP 开发者的重要资源。 查阅 “PHP 推荐读物列表”。 浏览 developerWorks 上的全部 PHP 内容。 查看 IBM developerWorks 的 PHP 项目资源 扩展 PHP 技巧。 收听针对软件开发人员的有趣访谈和讨论，一定要访问 developerWorks podcast。 要将数据库与 PHP 结合使用？查看 Zend Core for IBM，它是一个无缝的、可以立即使用、易于安装、支持 IBM DB2 V9 的 PHP 开发和生产环境。 随时关注 developerWorks 的 技术活动和网络广播。 查阅最近将在全球举办的面向 IBM 开放源码开发人员的研讨会、交易展览、网络广播和其他 活动。 访问 developerWorks 开放源码专区，获得丰富的 how-to 信息、工具和项目更新，帮助您用开放源码技术进行开发，并与 IBM 产品结合使用。 查看免费的 developerWorks On demand demo 观看并了解 IBM 及开源技术和产品功能。 获得产品和技术 使用 IBM 试用软件，改进您的下一个开发项目，这些软件可以通过下载或从 DVD 中获得。 下载 IBM 产品评估版 并开始使用来自 DB2®、Lotus®、Rational®、Tivoli® 和 WebSphere® 的应用程序开发工具和中间件产品。 讨论 参与 developerWorks blog 并加入 developerWorks 社区。 加入 developerWorks PHP Forum: Developing PHP applications with IBM Information Management products (DB2, IDS)。 注意 摘自IBM developerWorks,原文创作日期：2008 年 11 月 17 日，博主转载日期是 2017-02-28 10:07:41。 以上链接皆为原文中的链接，时效性未测，若信息陈旧，勿信！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git详解以及使用遇到问题解决]]></title>
    <url>%2F2017%2F02%2F27%2FGit%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[Git代码管理是分布式管理方式系统.优点在于其极高的安全性和非常强大的分支管理。 整体流程图 工作区(working directory):就是本地的代码区,电脑能看到的目录,就是工作区。 暂存区(Index):工作区下有一个隐藏的’.git’文件,其主要作用是存储Git自动创建的第一个master分支,还有指向master分支的HEAD指针.还有一个最重要的stage的暂存区.需要提交的文件修改通通放到暂存区,然后一次性提交到暂存区的所有修改。 本地仓:本地的个人仓库.管理着个人的代码的版本信息。 远程仓:线上的仓库.管理着推送到服务器的代码版本。 过程1: 由工作区暂存区工作区-&gt;暂存区:用git add . 添加所有的修改或者git add &lt;文件名&gt;添加单个指定的文件修改到暂存区中。 暂存区-&gt;工作区:(1)git rm --cached &quot;文件路径&quot;不删除物理文件,紧将物理文件删除； (2)git rm --f &quot;文件路径&quot;不仅将该文件从缓存中 删除,还将物理文件删除(不会放到垃圾桶； (3)git reset &lt;版本号&gt;利用版本库清空暂存区.原理:将当前分支重设(reset)到指定的或者HEAD(默认,如果不指定commit,默认是HEAD,即最新的一次提交)。 –hardgit reset --hard &lt;commit号&gt;重设(reset)index和working directory，自从以来在working directory中的任何改变都被丢弃，并把HEAD指向。 –softgit reset --hard &lt;commit号&gt;index和working directory中的内容不作任何改变，仅仅把HEAD指向。这个模式的效果是，执行完毕后，自从以来的所有改变都会显示在git status的”Changes to be committed”中。 过程2:由暂存区本地仓库暂存区-&gt;本地仓库 用git commit -m &#39;本次commit的描述&#39; 本地仓库-&gt;暂存区 git reset &lt;版本号&gt; 利用版本库清空暂存区.原理:将当前分支重设(reset)到指定的或者HEAD(默认,如果不指定commit,默认是HEAD,即最新的一次提交)。 –hardgit reset --hard &lt;commit号&gt;重设(reset)index和working directory，自从以来在working directory中的任何改变都被丢弃，并把HEAD指向 –softgit reset --hard &lt;commit号&gt;index和working directory中的内容不作任何改变，仅仅把HEAD指向。这个模式的效果是，执行完毕后，自从以来的所有改变都会显示在git status的”Changes to be committed”中.退回到该次commit提交,但是该版本之后所有的修改都没有了,如果想要恢复,就要试图从还未关闭的终端中找到你想要的退回的版本号,或者用git reflog查找你想要的commit版本号.继续用git reset --hard &lt;commit号&gt;回退。 过程3: 由本地仓-&gt;远程仓库用git push 在本地创建一个Git管理的项目1.从线上拉项目到本地用 git clone &quot;项目的地址路径&quot;克隆一个git管理的项目到本地2.本地项目上传线上git initgit remote add origin &quot;地址url&quot; Git上的常用查看操作1.查看文本内容cat &lt;文件名&gt;2.查看git的状态git status会告诉你在当前的分支上git的情况(有没有修改,修改的文件是什么等)➜ learngit git:(master) git status On branch master Your branch is up-to-date with &#39;origin/master&#39;. nothing to commit, working directory clean3.查看更详细的文件修改git diff 查看所有文件的不同git diff &lt;文件名&gt; 查看指定文件的不同diff 是difference的缩写.只能查看还未add(还没加入到暂存区)的修改4.查看所有的commit信息git loggit log --pretty=oneline 更简洁的查看log信息(只有commit号和描述信息)5.查看所有的git操作过的命令,可以找到删除了的commit号git reflog6.查看分支合并图git log --graph 冲突处理1 &lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD1 + 1 = 2 这个区间内的内容是当前开发者修改的 2 =======1 + 2 = 3 这个区间内的内容是其他开发者修改的 3 &gt;&gt;&gt;&gt;&gt;&gt;&gt;需要人工判断具体是删除或者保留哪一个修改内容.并且把1,2,3行提示删除掉. Git分支操作分支基本操作1.分支的创建和切换 git branch &quot;分支名&quot; 创建一个分支 git checkout &quot;分支名&quot; 切换到该分支 创建并切换到该分支 git checkout -b &quot;分支名&quot; 2.列出所有的分支 git branch 用*标记当前的分支 git branch -a 列出远程分支 3.合并分支 git merge &quot;分支名&quot;合并指定分支到当前分支 git rebase &quot;分支名&quot;合并指定分支到当前分支两者的区别在于会不会保留分支操作的记录,前者记录,后者不记录.建议用merge 4.删除分支 删除本地分支: git branch -d &quot;分支名&quot; 强制删除本地分支: git branch -D &quot;分支名&quot;如果提示the branch XXX is not fully merged(XXX分支有没有合并到当前分支的内容) 删除远程分支: git push origin :&lt;分支名&gt; (危险命令哦) 5.本地新建了一个分支要推送到线上,需要设置关联或者追踪. 第一次push: git push origin 本地分支名:远程分支名 6远程端生成了一个新的分支,拉取到本地. 先关联远程端分支到本地: git branch --set-upstream-to=origin/&lt;线上分支名&gt; &lt;本地分支名&gt; 然后git pull bug分支用issue作为分支的开头标记,当有一个bug出现需要改的时候,先拉取一个issue分支,修改并合并到开发分支上,然后删除issue分支. feature分支 开发新的功能的时候,最好拉去一个新的分支,以feature开头. 丢掉一个没有合并过的分支,即删除分支.(当新功能正在或者已经开发完,领导突然说不要了…心累)git branch -D &lt;分支名&gt; 强制删除该分支内容 暂存的使用1.git stash 暂存2.git stash list 查看所有的暂存3.git stash apply 从暂存开始执行,但是stash内容不会删除.4.git stash drop 删除暂存5.git stash pop 恢复暂存的同时删除暂存6.git stash apply stash@{0}恢复指定的暂存 远程仓的操作1.查看远程仓的信息git remotegit remote -v 显示更详细的信息2.将分支推送到远程仓git push origin 本地分支名:远程分支名 标签的使用1.git tag &lt;name&gt;新建一个标签2.git tag -a &lt;name&gt; -m &quot;指定的标签信息&quot;3.git show &lt;tag名字&gt; 查看详细的tag信息4.git tag 查看所有的tag名字5.git tag -d &lt;标签名字&gt;删除一个标签6.git push origin &lt;标签名&gt;推送标签到远程7.git push origin --tags一次性推送所有未推送的标签8.删除远程仓上的tag 先删除本地的标签: git tag -d &lt;tag名字&gt; 然后删除远程端的标签: git push origin :refs/tags/&lt;tag名字&gt; .gitignore的使用iOS 用到的.gitignore https://github.com/github/gitignore/blob/master/Objective-C.gitignore在工作区创建一个名字为.gitignore文件.把要忽略的文件名字填进去,并提交到Git.Git会自动忽略这些文件的修改.把链接中的内容信息copy到.gitignore文件中. 记住一定要把.gitignore拉取到具体的分支上才有用. git check-ignore 检查ignore内容 git add -f &lt;文件名&gt;即使在gitignore中文件,也可以提交. UserInterfaceState.xcuserstate 的屏蔽在. gitignore文件中加入UserInterfaceState.xcuserstate.在终端中输入git rm --cached &lt;你的工程名字&gt;.xcodeproj/project.xcworkspace/xcuserdata/&lt;该电脑用户名&gt;字.xcuserdatad/UserInterfaceState.xcuserstate然后add,commit,push等操作. Git 配置全局信息1.配置作者名称git config --global user.name &quot;Your Name&quot;2.配置个人邮箱git config --global user.email &quot;email@example.com&quot;3.配置git的颜色(文件名会标记上颜色)git config --global color.ui true Git上需要注意的单词 repository 仓库 software 软件 mode 模式,风格 insertion 插入 commit 把…托给 stage 原意:舞台,Git中是暂存区的意思. checkout 检出 branch 分支 modified 改进的,修改的 unstaged 还未加入到暂存区的 un + stage(暂存区) untracked 无足迹的,还没有加入git管理的 origin 起源,起点 reset 重设 rebase merge 合并 remote 遥远的,远程的 HEAD 表示当前版本 HEAD^ 上一个版本 HEAD^^ 上两个版本 HEAD~100 上100个版本 Linux的一些简单操作和一些符号的解释命令操作 目录/文件的操作 mkdir &quot;目录名&quot; 在当前路径下创建一个文件夹 mvdir &quot;目录1&quot; &quot;目录2&quot; 移动或者重命名一个目录 (如果目录2不存在,就直接修改目录1的名称为目录2) rmdir &quot;目录名&quot; 删除一个目录 touch 创建一个文件 vim &quot;文件名 编辑文件,如果文件不存在,就创建并进入编辑. 删除一个文件sudo rm -rf &lt;文件名&gt; 在上帝权限下删除,可以删除一个该用户没有权限的文件(包括系统文件),不建议使用rm &lt;文件名&gt;能删除当前用户权限下的文件 转换目录 cd + &quot;路径&quot; 进入该文件目录下(也可以将文件直接拖进来) cd .. 回到上级目录 cd . 当前目录 cd / 回到根目录 cd test.rtf 不可用. 不能cd到文件里.只能cd到目录.报错信息: -bash: cd: test.rtf: Not a directory 拷贝/移动/删除cp &quot;需要拷贝的文件路径&quot; &quot;目标地址路径&quot;拷贝文件 例如: cp /Users/goulela/Desktop/test.rtf /Users/goulela/Desktop/文件夹2mv &quot;需要移动的文件路径&quot; &quot;目标地址路径&quot;移动文件 例如: mv 文件夹2 /Users/goulela/Desktop/创建文件夹/文件夹 显示操作 file &quot;文件名&quot; 显示文件的类型 wc &quot;文件名&quot; 统计文件的字符数,词数,行数 pwd 查看当前所在的目录 ls 显示当前路径下有什么文件 ls + &quot;目录名&quot; 显示特定的路径下有什么文件 ls -w 显示中文 ls -l 详细信息 ls -a 显示所有文件,包括隐藏文件 时间操作 date 显示系统的当前日期和时间 cal 显示日历 网络与通信 ping &quot;url&quot; 给一个远程主机发送 回应请求 终止ping打印 control + c who 列出当前登录的所有用户 whoami 显示当前正进行操作的用户名 符号解释 -r 就是向下递归，不管有多少级目录，一并删除 -f 就是直接强行删除，不作任何提示的意思 -rf 向下递归强制删除 摘自简书，作者：满聪]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-Shell编程基础]]></title>
    <url>%2F2017%2F02%2F25%2Fshell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[简述使用 linux 就离不开 shell，那么也就是说也离不开 shell 编程。很多时候服务器都需要编写一些计划任务来定时运行的，所以掌握一些基本的 shell 编程基础很有必要。本文是我在网上收集的一些资料，主要目的是帮助自己更好的了解掌握 shell 编程的一些基础知识。 什么是Shell脚本示例看个例子吧：12345678#!/bin/shcd ~mkdir shell_tutcd shell_tutfor ((i=0; i&lt;10; i++)); do touch test_$i.txtdone 示例解释： 第1行：指定脚本解释器，这里是用/bin/sh做解释器的 第2行：切换到当前用户的home目录 第3行：创建一个目录shell_tut 第4行：切换到shell_tut目录 第5行：循环条件，一共循环10次 第6行：创建一个test_1…10.txt文件 第7行：循环体结束 12cd, mkdir, touch 都是系统自带的程序，一般在/bin或者/usr/bin目录下。for, do, done 是sh脚本语言的关键字。 shell和shell脚本的概念shell是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson的sh是第一种Unix Shell，Windows Explorer是一个典型的图形界面Shell。shell脚本（shell script），是一种为shell编写的脚本程序。业界所说的shell通常都是指shell脚本，但读者朋友要知道，shell和shell script是两个不同的概念。由于习惯的原因，简洁起见，本文出现的“shell编程”都是指shell脚本编程，不是指开发shell自身（如Windows Explorer扩展开发）。环境shell编程跟java、php编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。OS当前主流的操作系统都支持shell编程，本文档所述的shell编程是指Linux下的shell，讲的基本都是POSIX标准下的功能，所以，也适用于Unix及BSD（如Mac OS）。LinuxLinux默认安装就带了shell解释器。Mac OSMac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。Windows上的模拟器windows出厂时没有内置shell解释器，需要自行安装，为了同时能用grep, awk, curl等工具，最好装一个cygwin或者mingw来模拟linux环境。 cygwin mingw 脚本解释器 sh即Bourne shell，POSIX（Portable Operating System Interface）标准的shell解释器，它的二进制文件路径通常是/bin/sh，由Bell Labs开发。bashBash是Bourne shell的替代品，属GNU Project，二进制文件路径通常是/bin/bash。业界通常混用bash、sh、和shell，比如你会经常在招聘运维工程师的文案中见到：熟悉Linux Bash编程，精通Shell编程。在CentOS里，/bin/sh是一个指向/bin/bash的符号链接:1234[root@centosraw ~]# ls -l /bin/*sh-rwxr-xr-x. 1 root root 903272 Feb 22 05:09 /bin/bash-rwxr-xr-x. 1 root root 106216 Oct 17 2012 /bin/dashlrwxrwxrwx. 1 root root 4 Mar 22 10:22 /bin/sh -&gt; bash 但在Mac OS上不是，/bin/sh和/bin/bash是两个不同的文件，尽管它们的大小只相差100字节左右:1234567iMac:~ wuxiao$ ls -l /bin/*sh-r-xr-xr-x 1 root wheel 1371648 6 Nov 16:52 /bin/bash-rwxr-xr-x 2 root wheel 772992 6 Nov 16:52 /bin/csh-r-xr-xr-x 1 root wheel 2180736 6 Nov 16:52 /bin/ksh-r-xr-xr-x 1 root wheel 1371712 6 Nov 16:52 /bin/sh-rwxr-xr-x 2 root wheel 772992 6 Nov 16:52 /bin/tcsh-rwxr-xr-x 1 root wheel 1103984 6 Nov 16:52 /bin/zsh 如何选择shell编程语言熟悉 vs 陌生如果你已经掌握了一门编程语言（如PHP、Python、Java、JavaScript），建议你就直接使用这门语言编写脚本程序，虽然某些地方会有点啰嗦，但你能利用在这门语言领域里的经验（单元测试、单步调试、IDE、第三方类库）。新增的学习成本很小，只要学会怎么使用shell解释器（Jshell、AdaScript）就可以了。简单 vs 高级如果你觉得自己熟悉的语言（如Java、C）写shell脚本实在太啰嗦，你只是想做一些备份文件、安装软件、下载数据之类的事情，学着使用sh，bash会是一个好主意。shell只定义了一个非常简单的编程语言，所以，如果你的脚本程序复杂度较高，或者要操作的数据结构比较复杂，那么还是应该使用Python、Perl这样的脚本语言，或者是你本来就已经很擅长的高级语言。因为sh和bash在这方面很弱，比如说： 它的函数只能返回字串，无法返回数组 它不支持面向对象，你无法实现一些优雅的设计模式 它是解释型的，一边解释一边执行，连PHP那种预编译都不是，如果你的脚本包含错误(例如调用了不存在的函数)，只要没执行到这一行，就不会报错 环境兼容性如果你的脚本是提供给别的用户使用，使用sh或者bash，你的脚本将具有最好的环境兼容性，perl很早就是linux标配了，python这些年也成了一些linux发行版的标配，至于mac os，它默认安装了perl、python、ruby、php、java等主流编程语言。第一个shell脚本 编写打开文本编辑器，新建一个文件，扩展名为sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用php写shell 脚本，扩展名就用php好了。输入一些代码，第一行一般是这样： 12#!/bin/bash#!/usr/bin/php “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行。 运行运行Shell脚本有两种方法： 1、作为可执行程序将上面的代码保存为test.sh，并cd到相应目录：1chmod +x ./test.sh #使脚本具有执行权限 1./test.sh #执行脚本 注意： 一定要写成./test.sh，而不是test.sh，运行其它二进制的程序也一样。 直接写test.sh，linux 系统会去PATH里寻找有没有叫test.sh的，只有/bin, /sbin, /usr/bin，/usr/sbin等在PATH里。 你的当前目录通常不在PATH里，所以写成test.sh是会找不到命令的，要用./test.sh告诉系统说，就在当前目录找。 2、作为解释器参数这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名，如：1/bin/sh test.sh 1/bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 变量定义变量定义变量时，变量名不加美元符号（$），如：1your_name=&quot;qinjx&quot; 注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样： 首个字母必须为字母（a-z,A-Z）。 中间不能有空格，可以使用下划线。 不能使用表单符号。 不能使用bash里的关键字（如果不清楚，可以用help命令查看bash的保留关键字）。 除了显式地直接赋值，还可以用语句给变量赋值，如：1for file in `ls /etc` 说明：上面的命令的意思是实现将 /etc 下目录的文件名循环出来。 使用变量使用一个定义过得变量，只要在变量名之前加上美元符号 $ 即可，比如：123your_name=&quot;qinjx&quot;echo $your_nameecho $&#123;your_name&#125; 变量名外面的花括号是可选的，可加可不加，加花括号是为了帮助解释器识别变量的边界，比如当遇到下面的情况时：123for skill in Ada Coffe Action Java; do echo &quot;I am good at $&#123;skill&#125;Script&quot;done 如果不给skill变量加上花括号，变量写成 $skillScript，那么解释器就识别不出$skill了，那么代码的最终结果就跟我的预期相差甚远。推荐给所有变量加上花括号，这是shell编程的好习惯。对于已定义的变量，可以被重新定义，比如：1234your_name="tom"echo $your_nameyour_name="alibaba"echo $your_name 注意第二次赋值的时候不能写成：1$your_name=&quot;alibaba&quot; 只有在使用变量的时候才加美元符 $。 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。下面的例子尝试更改只读变量，结果报错：1234#!/bin/bashmyUrl=&quot;http://www.w3cschool.cc&quot;readonly myUrlmyUrl=&quot;http://www.runoob.com&quot; 运行脚本，结果如下：1/bin/sh: NAME: This variable is read only. 删除变量使用 unset 命令可以删除变量。语法：1unset variable_name 变量被删除后不能再次使用。unset 命令不能删除只读变量。案例：1234#!/bin/shmyUrl=&quot;http://www.runoob.com&quot;unset myUrlecho $myUrl 上面的程序执行将没有任何输出。 变量类型运行 shell 程序时，会同时存在三种变量： 局部变量： 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量： 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量：shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 字符串字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了）。字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。 单引号1str=&apos;this is a string&apos; 单引号字符串的限制： 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的。 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。 双引号12your_name=&apos;qinjx&apos;str=&quot;Hello, I know your are \&quot;$your_name\&quot;! \n&quot; 双引号的优点： 双引号里可以有变量。 双引号里可以出现转义字符。 拼接字符串1234your_name=&quot;qinjx&quot;greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;echo $greeting $greeting_1 获取字符串长度12string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4 提取子字符串以下实例从字符串第 2 个字符开始截取 4 个字符： 12string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo 查找子字符串查找字符 “i 或 s” 的位置： 12string=&quot;runoob is a great company&quot;echo `expr index &quot;$string&quot; is` # 输出 8 注意： 以上脚本中 是反引号，而不是单引号 ，千万不要看错了。 数组Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。 获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于0。 数组中可以存放多个值，与大部分编程语言类似，数组元素的下标由0开始。 定义数组在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。 定义数组的一般形式为： 1数组名=(值1 值2 ... 值n) 例如： 1array_name=(value0 value1 value2 value3) 或者 123456array_name=(value0value1value2value3) 还可以单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组读取数组元素值的一般格式是： 1$&#123;数组名[下标]&#125; 例如： 1valuen=$&#123;array_name[n]&#125; shell 编程实战： 12345678#!/bin/bashmy_array=(A B &quot;C&quot; D)echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot; 执行脚本，输出结果如下所示： 123456$ chmod +x test.sh$ ./test.sh第一个元素为: A第二个元素为: B第三个元素为: C第四个元素为: D 使用 @ 或者 * 符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; shell 编程实战： 123456789#!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot; 执行脚本，输出结果如下所示： 1234$ chmod +x test.sh$ ./test.sh数组的元素为: A B C D数组的元素为: A B C D 获取数组的长度获取数组长度的方法与获取字符串长度的方法相同，例如： 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; shell 实战编程： 123456789#!/bin/bashmy_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot; 执行脚本，输出结果如下所示： 1234$ chmod +x test.sh$ ./test.sh数组元素个数为: 4数组元素个数为: 4 注释以”#”开头的行就是注释，会被解释器忽略。 sh里没有多行注释，只能每一行加一个#号。只能像这样： 12345678910#--------------------------------------------# 这是一个注释#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息####### 用户配置区 结束 ##### 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 传递参数我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。 1n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推…… 实例以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名： 1234567#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 为脚本设置可执行权限，并执行脚本，输出结果如下所示： 1234567$ chmod +x test.sh$ ./test.sh 1 2 3Shell 传递参数实例！执行的文件名：test.sh第一个参数为：1第二个参数为：2第三个参数为：3 另外，还有几个特殊字符用来处理参数： 12345678910参数处理 说明$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数。如&quot;$*&quot;用「&quot;」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如&quot;$@&quot;用「&quot;」括起来的情况、以&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot; 的形式输出所有参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 1234567#!/bin/bashecho &quot;Shell 传递参数实例！&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;参数个数为：$#&quot;;echo &quot;传递的参数作为一个字符串显示：$*&quot;; 执行脚本，输出结果如下所示： 123456$ chmod +x test.sh$ ./test.sh 1 2 3Shell 传递参数实例！第一个参数为：1参数个数为：3传递的参数作为一个字符串显示：1 2 3 $* 与 $@ 区别： 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。 1假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 &quot;1 2 3&quot;（传递了一个参数），而 &quot;@&quot; 等价于 &quot;1&quot; &quot;2&quot; &quot;3&quot;（传递了三个参数）。 1234567891011#!/bin/bashecho &quot;-- \$* 演示 ---&quot;for i in &quot;$*&quot;; do echo $idoneecho &quot;-- \$@ 演示 ---&quot;for i in &quot;$@&quot;; do echo $idone 执行脚本，输出结果如下所示： 12345678$ chmod +x test.sh$ ./test.sh 1 2 3-- $* 演示 ---1 2 3-- $@ 演示 ---123 基本运算符Shell 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(特别注意：使用的是反引号 ` 而不是单引号 ‘)： 1234#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为 : $val&quot; 执行脚本，输出结果如下所示： 1两数之和为 : 4 两点注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符下面列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 123456789运算符 说明 举例 + 加法 `expr $a + $b` 结果为 30。 + 减法 `expr $a - $b` 结果为 10。 + 乘法 `expr $a \* $b` 结果为 200。/ 除法 `expr $b / $a` 结果为 2。% 取余 `expr $b % $a` 结果为 0。= 赋值 a=$b 将把变量 b 的值赋给 a。== 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 示例算术运算符实例如下： 12345678910111213141516171819202122232425262728#!/bin/basha=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a 等于 b&quot;fiif [ $a != $b ]then echo &quot;a 不等于 b&quot;fi 执行脚本，输出结果如下所示： 123456a + b : 30a - b : -10a * b : 200b / a : 2b % a : 0a 不等于 b 注意： 乘号(*)前边必须加反斜杠()才能实现乘法运算。 if…then…fi 是条件语句，后续会有说明。 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下面列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 1234567运算符 说明 举例-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。-ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。-ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 实例关系运算符实例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#!/bin/basha=10b=20if [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot;else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot;else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot;else echo &quot;$a -le $b: a 大于 b&quot;fi 执行脚本，输出结果如下所示： 12345610 -eq 20: a 不等于 b10 -ne 20: a 不等于 b10 -gt 20: a 不大于 b10 -lt 20: a 小于 b10 -ge 20: a 小于 b10 -le 20: a 小于或等于 b 布尔运算符下面列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 1234运算符 说明 举例! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 实例布尔运算符实例如下： 1234567891011121314151617181920212223242526272829#!/bin/basha=10b=20if [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then echo &quot;$a -lt 100 -a $b -gt 15 : 返回 true&quot;else echo &quot;$a -lt 100 -a $b -gt 15 : 返回 false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then echo &quot;$a -lt 100 -o $b -gt 100 : 返回 true&quot;else echo &quot;$a -lt 100 -o $b -gt 100 : 返回 false&quot;fiif [ $a -lt 5 -o $b -gt 100 ]then echo &quot;$a -lt 100 -o $b -gt 100 : 返回 true&quot;else echo &quot;$a -lt 100 -o $b -gt 100 : 返回 false&quot;fi 执行脚本，输出结果如下所示： 123410 != 20 : a 不等于 b10 -lt 100 -a 20 -gt 15 : 返回 true10 -lt 100 -o 20 -gt 100 : 返回 true10 -lt 100 -o 20 -gt 100 : 返回 false 逻辑运算符以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 123运算符 说明 举例&amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false|| 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true 实例逻辑运算符实例如下： 123456789101112131415161718#!/bin/basha=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fiif [[ $a -lt 100 || $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fi 执行脚本，输出结果如下所示： 12返回 false返回 true 字符串运算符下面列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 123456运算符 说明 举例= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。!= 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。-n 检测字符串长度是否为0，不为0返回 true。 [ -n $a ] 返回 true。str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 实例1234567891011121314151617181920212223242526272829303132333435#!/bin/basha=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then echo &quot;$a = $b : a 等于 b&quot;else echo &quot;$a = $b: a 不等于 b&quot;fiif [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ -z $a ]then echo &quot;-z $a : 字符串长度为 0&quot;else echo &quot;-z $a : 字符串长度不为 0&quot;fiif [ -n $a ]then echo &quot;-n $a : 字符串长度不为 0&quot;else echo &quot;-n $a : 字符串长度为 0&quot;fiif [ $a ]then echo &quot;$a : 字符串不为空&quot;else echo &quot;$a : 字符串为空&quot;fi 执行脚本，输出结果如下所示： 12345abc = efg: a 不等于 babc != efg : a 不等于 b-z abc : 字符串长度不为 0-n abc : 字符串长度不为 0abc : 字符串不为空 文件测试运算符文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 1234567891011121314操作符 说明 举例-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。-p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 实例变量 file 表示文件”/var/www/runoob/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashfile=&quot;/var/www/runoob/test.sh&quot;if [ -r $file ]then echo &quot;文件可读&quot;else echo &quot;文件不可读&quot;fiif [ -w $file ]then echo &quot;文件可写&quot;else echo &quot;文件不可写&quot;fiif [ -x $file ]then echo &quot;文件可执行&quot;else echo &quot;文件不可执行&quot;fiif [ -f $file ]then echo &quot;文件为普通文件&quot;else echo &quot;文件为特殊文件&quot;fiif [ -d $file ]then echo &quot;文件是个目录&quot;else echo &quot;文件不是个目录&quot;fiif [ -s $file ]then echo &quot;文件不为空&quot;else echo &quot;文件为空&quot;fiif [ -e $file ]then echo &quot;文件存在&quot;else echo &quot;文件不存在&quot;fi 执行脚本，输出结果如下所示： 1234567文件可读文件可写文件可执行文件为普通文件文件不是个目录文件不为空文件存在 echo命令Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。 命令格式： 1echo string 您可以使用echo实现更复杂的输出格式控制。 1.显示普通字符串:1echo &quot;It is a test&quot; 这里的双引号完全可以省略，以下命令与上面实例效果一致： 1echo It is a test 2.显示转义字符1echo &quot;\&quot;It is a test\&quot;&quot; 结果将是: 1&quot;It is a test&quot; 同样，双引号也可以省略 3.显示变量read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量: 123#!/bin/shread nameecho &quot;$name It is a test&quot; 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是: 123[root@www ~]# sh test.shOK #标准输入OK It is a test #输出 4.显示换行12echo -e &quot;OK! \n&quot; # -e 开启转义echo &quot;It it a test&quot; 输出结果： 123OK!It it a test 5.显示不换行123#!/bin/shecho -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行echo &quot;It is a test&quot; 输出结果： 1OK! It is a test 6.显示结果定向至文件1echo &quot;It is a test&quot; &gt; myfile 7.原样输出字符串，不进行转义或取变量(用单引号)1echo &apos;$name\&quot;&apos; 输出结果： 1$name\&quot; 8.显示命令执行结果1echo `date` 结果将显示当前日期 1Thu Jul 24 10:08:46 CST 2014 printf 命令printf 命令模仿 C 程序库（library）里的 printf() 程序。 标准所定义，因此使用printf的脚本比使用echo移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在printf中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。 默认printf不会像 echo 自动添加换行符，我们可以手动添加 n。 printf 命令的语法： 1printf format-string [arguments...] 参数说明： format-string: 为格式控制字符串 arguments: 为参数列表。 实例112345$ echo &quot;Hello, Shell&quot;Hello, Shell$ printf &quot;Hello, Shell\n&quot;Hello, Shell$ 接下来,我来用一个脚本来体现printf的强大功能： 123456#!/bin/bashprintf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kgprintf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 执行脚本，输出结果如下所示： 1234姓名 性别 体重kg郭靖 男 66.12杨过 男 48.65郭芙 女 47.99 1234%s %c %d %f都是格式替代符。%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f 指格式化为小数，其中.2指保留2位小数。 实例21234567891011121314151617181920#!/bin/bash# format-string为双引号printf &quot;%d %s\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样printf &apos;%d %s\n&apos; 1 &quot;abc&quot;# 没有引号也可以输出printf %s abcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf &quot;%s\n&quot; abc defprintf &quot;%s %s %s\n&quot; a b c d e f g h i j# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \n&quot; 执行脚本，输出结果如下所示： 1234567891 abc1 abcabcdefabcdefabcdefa b cd e fg h ij and 0 printf 的转义序列123456789101112序列 说明\a 警告字符，通常为ASCII的BEL字符\b 后退\c 抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略\f 换页（formfeed）\n 换行\r 回车（Carriage return）\t 水平制表符\v 垂直制表符\\ 一个字面上的反斜杠字符\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效\0ddd 表示1到3位的八进制值字符 实例123456789$ printf &quot;a string, no processing:&lt;%s&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;A\nB&gt;$ printf &quot;a string, no processing:&lt;%b&gt;\n&quot; &quot;A\nB&quot;a string, no processing:&lt;AB&gt;$ printf &quot;www.runoob.com \a&quot;www.runoob.com $ #不换行 test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 数值测试1234567参数 说明-eq 等于则为真-ne 不等于则为真-gt 大于则为真-ge 大于等于则为真-lt 小于则为真-le 小于等于则为真 实例12345678num1=100num2=100if test $[num1] -eq $[num2]then echo &apos;两个数相等！&apos;else echo &apos;两个数不相等！&apos;fi 输出结果： 1两个数相等！ 字符串测试12345参数 说明= 等于则为真!= 不相等则为真-z 字符串 字符串的长度为零则为真-n 字符串 字符串的长度不为零则为真 实例12345678num1=&quot;runoob&quot;num2=&quot;runoob&quot;if test num1=num2then echo &apos;两个字符串相等!&apos;else echo &apos;两个字符串不相等!&apos;fi 输出结果： 1两个字符串相等！ 文件测试12345678910参数 说明-e 文件名 如果文件存在则为真-r 文件名 如果文件存在且可读则为真-w 文件名 如果文件存在且可写则为真-x 文件名 如果文件存在且可执行则为真-s 文件名 如果文件存在且至少有一个字符则为真-d 文件名 如果文件存在且为目录则为真-f 文件名 如果文件存在且为普通文件则为真-c 文件名 如果文件存在且为字符型特殊文件则为真-b 文件名 如果文件存在且为块特殊文件则为真 实例1234567cd /binif test -e ./bashthen echo &apos;文件已存在!&apos;else echo &apos;文件不存在!&apos;fi 输出结果： 1文件已存在! 1另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!&quot;最高，&quot;-a&quot;次之，&quot;-o&quot;最低。 例如： 1234567cd /binif test -e ./notFile -o -e ./bashthen echo &apos;有一个文件存在!&apos;else echo &apos;两个文件都不存在&apos;fi 输出结果： 1有一个文件存在! 流程控制和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)： 1234567&lt;?phpif (isset($_GET[&quot;q&quot;])) &#123; search(q);&#125;else &#123; // 不做任何事情&#125; 在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。 if elseifif 语句语法格式： 1234567if conditionthen command1 command2 ... commandNfi 写成一行（适用于终端命令提示符）： 1if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 if elseif else 语法格式： 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if elseif else-if else 语法格式： 123456789if condition1then command1elif condition2then command2else commandNfi 以下实例判断两个变量是否相等： 1234567891011121314a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 输出结果： 1a 小于 b if else语句经常与test命令结合使用，如下所示： 12345678num1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then echo &apos;两个数字相等!&apos;else echo &apos;两个数字不相等!&apos;fi 输出结果： 1两个数字相等! for 循环与其他编程语言类似，Shell支持for循环。 for循环一般格式为： 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 写成一行： 1for var in item1 item2 ... itemN; do command1; command2… done; 当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。 命令可为任何有效的shell命令和语句。 in列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 例如，顺序输出当前列表中的数字： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 输出结果： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 顺序输出字符串中的字符： 1234for str in &apos;This is a string&apos;do echo $strdone 输出结果： 1This is a string while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据，命令通常为测试条件。 其格式为： 1234while conditiondo commanddone 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。 int从0开始，每次循环处理时，int加1。 运行上述脚本，返回数字1到5，然后终止。 1234567#!/bin/shint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 运行脚本，输出： 1234512345 脚本中使用了 let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 while循环可用于读取键盘信息。 下面的例子中，输入信息被设置为变量FILM，按结束循环。 123456echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;echo -n &apos;输入你最喜欢的电影名: &apos;while read FILMdo echo &quot;是的！$FILM 是一部好电影&quot;done 运行脚本，输出类似下面： 123按下 &lt;CTRL-D&gt; 退出输入你最喜欢的电影名: w3cschool菜鸟教程是的！w3cschool菜鸟教程 是一部好电影 无限循环无限循环语法格式： 1234while :do commanddone 或者 1234while truedo commanddone 或者 1for (( ; ; )) until 循环until循环执行一系列命令直至条件为真时停止。 until循环与while循环在处理方式上刚好相反。 一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。 until 语法格式: 1234until conditiondo commanddone 条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次—请注意这一点。 caseShell case语句为多选择语句。 可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。 case语句格式如下： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac case工作方式如上所示。 取值后面必须为单词in，每一模式必须以右括号结束。 取值可以为变量或常数。 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。 取值将检测匹配的每一个模式。 一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 下面的脚本提示输入1到4，与每一种模式进行匹配： 123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 输入不同的内容，会有不同的结果，例如： 1234输入 1 到 4 之间的数字:你输入的数字为:3你选择了 3 esaccase的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。 跳出循环在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。 break命令break命令允许跳出所有循环（终止执行后面的所有循环）。 下面的例子中，脚本进入死循环直至用户输入数字大于5。 要跳出这个循环，返回到shell提示符下，需要使用break命令。 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone 执行以上代码，输出结果为： 1234输入 1 到 5 之间的数字:3你输入的数字为 3!输入 1 到 5 之间的数字:7你输入的数字不是 1 到 5 之间的! 游戏结束 continuecontinue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。 对上面的例子进行修改： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “Game is over!” 永远不会被执行。 函数linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。 shell中函数的定义格式如下： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 说明： 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255 下面的例子定义了一个函数并进行调用： 12345678#!/bin/bashdemoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 输出结果： 123-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 下面定义一个带有return语句的函数： 12345678910111213#!/bin/bashfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 输出类似下面： 1234567这个函数会对输入的两个数字进行相加运算...输入第一个数字:1输入第二个数字:2两个数字分别为 1 和 2 !输入的两个数字之和为 3 ! 函数返回值在调用该函数后通过 $? 来获得。 注意： 所有函数在使用前必须定义。 这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。 调用函数仅使用其函数名即可。 函数参数在Shell中，调用函数时可以向其传递参数。 在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 带参数的函数示例： 123456789101112#!/bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果： 1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 另外，还有几个特殊字符用来处理参数： 12345678参数处理 说明$# 传递到脚本的参数个数$* 以一个单字符串显示所有向脚本传递的参数$$ 脚本运行的当前进程ID号$! 后台运行的最后一个进程的ID号$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。$- 显示Shell使用的当前选项，与set命令功能相同。$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向命令如下： 123456789命令 说明command &gt; file 将输出重定向到 file。command &lt; file 将输入重定向到 file。command &gt;&gt; file 将输出以追加的方式重定向到 file。n &gt; file 将文件描述符为 n 的文件重定向到 file。n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。n &gt;&amp; m 将输出文件 m 和 n 合并。n &lt;&amp; m 将输入文件 m 和 n 合并。&lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 1需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 输出重定向重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示: 1command1 &gt; file1 上面这个命令执行command1然后将输出的内容存入file1。 注意：任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。 实例执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users): 1$ who &gt; users 执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。 你可以使用 cat 命令查看文件内容： 1234$ cat users_mbsetupuser console Oct 31 17:35tianqixin console Oct 31 17:35tianqixin ttys000 Dec 1 11:33 输出重定向会覆盖文件内容，请看下面的例子： 1234$ echo &quot;测试测试：www.runoob.com&quot; &gt; users$ cat users测试测试：www.runoob.com$ 如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如： 12345$ echo &quot;测试测试：www.runoob.com&quot; &gt;&gt; users$ cat users测试测试：www.runoob.com测试测试：www.runoob.com$ 输入重定向和输出重定向一样，Unix 命令也可以从文件获取输入，语法为： 1command1 &lt; file1 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。 注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。 实例接着以上实例，我们需要统计 users 文件的行数,执行以下命令： 12$ wc -l users 2 users 也可以将输入重定向到 users 文件： 12$ wc -l &lt; users 2 注意：上面两个例子的结果不同： 第一个例子，会输出文件名。 第二个不会，因为它仅仅知道从标准输入读取内容。 command1 &lt; infile &gt; outfile 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。 重定向深入理解一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 如果希望 stderr 重定向到 file，可以这样写： 1$ command 2 &gt; file 如果希望 stderr 追加到 file 文件末尾，可以这样写： 1$ command 2 &gt;&gt; file 2 表示标准错误文件(stderr)。 如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写： 1$ command &gt; file 2&gt;&amp;1 或者 1$ command &gt;&gt; file 2&gt;&amp;1 如果希望对 stdin 和 stdout 都重定向，可以这样写： 1$ command &lt; file1 &gt;file2 command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。 Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 实例在命令行中通过 wc -l 命令计算 Here Document 的行数： 1234567$ wc -l &lt;&lt; EOF 测试 测试测试 www.runoob.comEOF3 # 输出结果为 3 行$ 我们也可以将 Here Document 用在脚本中，例如： 1234567#!/bin/bashcat &lt;&lt; EOF厕所测试www.runoob.comEOF 执行以上脚本，输出结果： 123厕所测试www.runoob.com /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1$ command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃。 如果尝试从该文件读取内容，那么什么也读不到。 但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1$ command &gt; /dev/null 2&gt;&amp;1 注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 文件包含和其他语言一样，Shell 也可以包含外部脚本。 这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下： 1. filename # 注意点号(.)和文件名中间有一空格 或 1source filename 实例创建两个 shell 脚本文件。 test1.sh 代码如下： 123#!/bin/bashurl=&quot;http://www.runoob.com&quot; test2.sh 代码如下： 12345678#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;测试地址：$url&quot; 接下来，我们为 test2.sh 添加可执行权限并执行： 123$ chmod +x test2.sh$ ./test2.sh测试地址：http://www.runoob.com 注：被包含的文件 test1.sh 不需要可执行权限。 摘自segmentfault，作者：AlphaGooo]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给中级程序员水平突破瓶颈的8个建议]]></title>
    <url>%2F2017%2F02%2F23%2F%E7%BB%99%E4%B8%AD%E7%BA%A7%E7%A8%8B%E5%BA%8F%E5%91%98%E6%B0%B4%E5%B9%B3%E7%AA%81%E7%A0%B4%E7%93%B6%E9%A2%88%E7%9A%848%E4%B8%AA%E5%BB%BA%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[首先我们要知道，在程序员这个职业中，究竟是天赋重要还是兴趣和努力重要？ 而我的回答是，说天赋重要的人，只是在为自己不如别人刻苦而找出的借口。我最近也读了很多有关如何提升自我水平的文章，大部分文章以K. Anders Ericsson的研究结论为出发点的文章，也就是说天才的成就，虽然和他的天赋有一定的关系，但心理学家越是深入考察天才们的人生经历，就会发现天赋到了后期它的作用会越来越小，而后天储备的作用却越来越明显。 我发现大多数人提升的编程水平，所推荐的方法是一些很基础的事情。如，阅读代码、理解代码、编写代码、参加项目、讨论代码等等……当然，这些作法确实能够帮助程序员提升水平，但其实际效果显然是非常小的。 下面我会结合自己学习编程的经历，跟大家聊聊其中的优势与弊端： 1.通过编程竞赛进行实践 我会参加各类编程竞赛，总体来讲，用比赛来学习新语言并不现实。它提供的反馈循环较弱——我们只能了解到自己的程序能否正确输出，但设计流程不会受到评判。这种方法只能帮助大家了解新的算法或者特性，但在实践层面来讲，效果偏弱，它更着重“表现”而非“实践”。 2.通过在线课程学习提高 网上有很多精华的教程可以进行学习，有很多大牛分享出来的最新的技术和开发经验，对自己的水平提升非常有作用。这里强烈介绍php中文网的在线视频课程，他们每周都会推出一门最新的视频课程，这里有php中文网自己原创的视频也有一些知名机构和个人的视频，关键都是都是免费的，这些精品课程对我的开发水平提升非常有帮助！ 3. 阅读关于编程的书籍 阅读相关书籍能够帮助我们快速提升知识储备，因此有关“水平提升”方案都会有这项要求。在这里给大家推荐5本非常棒的编程图书，这些精华图书都实实在在地给了我极大的帮助。它们值得反复阅读，且每次都能让我在软件工程方面获得更为深入、更具穿透力的见识。如果你还没读过这些书，那你还在等什么呢？ 这5本书是： 《代码大全（第二版）》 《点石成金：访客至上的网页设计秘笈》（即《Don’t Make Me Think》） 《人件》 《程序员修炼之道：从小工到专家》 《软件工程的事实与谬误》 4.学习快速搜索技术、手段 作为一名好的程序员，不仅仅是技能的问题了，而你寻找信息的技巧也非常重要，而这个趋势会越来越明显。你应该学会，如何接近特定的搜索，以及了解自己实际上想查些什么，信息筛选可以通过组建思维知识图谱来提升。最后搜索多了，经验上去了，就知道一些高质量的网站和一些通常的说明文档位置，使得你的问题的求解更加容易，包括像应该使用哪种搜索引擎（提示：普通的搜索引擎不一定就是最佳选择），使用普通搜索引擎前应该访问哪个网站，甚至是应该到哪个论坛去寻求帮助，等等。 5.帮助别人 如果可能的话，帮助那些寻求帮助的人。这是一件很好的事情，也是聪明人的做法。教别人始终是学习一切东西的最好方法之一。记住，你所学到的一切都是你从别人或别处学到的；因此请尝试一下，每天尽量花一点时间试着回答网站上的问题，其他网站的也可以。就算读读其他人的回答，你也可以学到很多东西。 6.多编码才是王道 研究表明，要成为一名“专家”，这至少需要花费10年的时间，或者10000到20000小时的刻意练习的时间，做几年程序员是不够的。 想在30岁左右成为一名高级软件开发工程师？要么尽早接受教育/培训，要么你得愿意在闲暇时间进行大量的工作、阅读和练习。我从高中开始编程，还牺牲了许多休息时间去跟踪行业发展、学习新技能等等。结果，我获得中级和高级程序员的时间就比我的大部分同事都要早得多，随着时间的推移，这些就转化成为宝贵的经验。 7.看看高级程序员的代码 在工作中看看高级程序员写的代码，然后问一问他们为什么以某种特别的方式来完成这个项目，也可以学习他好的编程习惯，从中得到反思。但值得注意的是不要生搬硬套别人的东西；你要能领会到哪些是能行的通的，哪些是有道理的，然后再模仿人家，并不断摸索适合自己的语言。 8.态度是关键 如果你不喜欢自己的工作，且目前的水平还是初级，那么如何成为中级的水平或者让情况有所好转，不妨换工作或改职业吧。反过来说，如果你喜爱所从事的工作，那就好！少一些浮躁，沉下心来体会技术的真正精髓，踏踏实实的做，最终会有一个好的归宿。只要你坚持下去，我保证你能成为一名更好的程序员。 每个人都有自己成长的方式，以上建议仅作参考，祝你能够早日找到一条属于自己的光明大道！ 摘自：php中文网网友西风投稿]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.14情人节]]></title>
    <url>%2F2017%2F02%2F14%2F2-14%E6%83%85%E4%BA%BA%E8%8A%82%2F</url>
    <content type="text"><![CDATA[The page were create on 2017-02-14 5:20pm.暂时不知道想写什么，先创建这个，等文章准备好了再补充吧。 ：)]]></content>
      <categories>
        <category>Festival</category>
      </categories>
      <tags>
        <tag>festival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元宵节灯谜]]></title>
    <url>%2F2017%2F02%2F11%2F%E5%85%83%E5%AE%B5%E8%8A%82%E7%81%AF%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[The page were create on 2017-02-11 17:21:40;2nd edit was on 2017-02-13 14:07:30;3rd edit was on 2017-02-16 14:50:30 for fixing the table done. td,th{ text-align: center; line-height: 2.5em; } 序号灯谜答案 1老会计喝二锅头（打一热门技术）云计算 2 梦中交谈(打一热门技术)虚拟化 3 拳王的金腰带（打一网络技术） 宽带 4 小米大合唱（打一著名互联网厂商）谷歌 5 男女生都一样（打一技术术语）兼容性 6 不达目的誓不罢休（打一著名网络解决方案提供商）思科 7 席卷天下，包举宇内，囊括四海，并吞八荒（打一互联网技术）广域网 8 话又说回来了（打一网络安全术语） 循环语句 9 禽流感（打一常见的PC/服务器故障）死机 10 深夜造访（打一网络安全术语） 黑客 11 屡屡破记录（打一技术术语）超频 12 不听话就得打（打一网络安全术语）拒绝服务攻击 13 驴友上路多郁闷（打一网络设备）路由器 14 月老难扯二人姻缘（打一网络技术）无线 15 光芒照四方（打一安全厂商）金山 16 网管抓狂（打一网络设备）网卡 17 王老吉面壁（打一网络安全设备）防火墙 18 单个花生超产（打一芯片技术）多核 19 整个界面都是阿凡达（打一PC/服务器故障现象）蓝屏 20 E（打一开发语言）C++ 21 连胜六场又赢了（打一知名操作系统）win7 22 方便月老配对象（打一网络设备）集线器 23 走麦城（打一网络安全设备）网关 24 皇帝绷着脸（打一设备）主板 25 太上老君的金丹（打一网络安全术语）密匙 26 悟空出了五指山（打一技术术语）解压 L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});]]></content>
      <categories>
        <category>Festival</category>
      </categories>
      <tags>
        <tag>festival</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Page]]></title>
    <url>%2F2017%2F02%2F11%2FFirst-Page%2F</url>
    <content type="text"><![CDATA[It’s my first blog page , I want to upload before having a look.gdbbn805a]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ThemesDocumentMore info: Themes Theme : NexTMore info: NexT NexT : Comment SystemMore info: Comment System]]></content>
  </entry>
</search>
